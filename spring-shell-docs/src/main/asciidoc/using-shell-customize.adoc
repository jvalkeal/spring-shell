=== Customizing the Shell

[[overriding-or-disabling-built-in-commands]]
==== Overriding or Disabling Built-In Commands

Spring Shell provides <<built-in-commands,Built-in commands>> to let people achieve everyday tasks that many if not
all shell applications need. If you are not happy with the way they behave, though, you can disable or override them,
as explained in this section.

[TIP]
.Disabling all Built-in Commands
=====
If you do not need built-in commands at all, there is an easy way to "`disable`" them: don't include them.
Either use a maven exclusion on `spring-shell-standard-commands` or, if you are selectively including Spring Shell
dependencies, don't include that one in. The follwoing example shows how to exclude `spring-shell-standard-commands`:

====
[source,xml,subs=attributes+]
----
<dependency>
    <groupId>org.springframework.shell</groupId>
    <artifactId>{starter-artifactId}</artifactId>
    <version>{project-version}</version>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.shell</groupId>
            <artifactId>spring-shell-standard-commands</artifactId>
        </exclusion>
    </exclusions>
</dependency>
----
====
=====

[[disabling-specific-commands]]
===== Disabling Specific Commands

To disable a single built-in command, set the `spring.shell.command.<command>.enabled` property to `false` in the
application `Environment`. One way to do so is to pass extra arguments to the Boot application in your `main()`
entry point:

====
[source, java]
----
	public static void main(String[] args) throws Exception {
		String[] disabledCommands = {"--spring.shell.command.help.enabled=false"}; // <1>
		String[] fullArgs = StringUtils.concatenateStringArrays(args, disabledCommands);
		SpringApplication.run(MyApp.class, fullArgs);
	}
----
<1> This disables the integrated `help` command
====

===== Overriding Specific Commands

If, instead of disabling a command, you would rather provide your own implementation, then you can either:

* Disable the command as explained <<disabling-specific-commands,earlier>> and have your implementation registered
with the same name.
* Have your implementing class implement the `<Command>.Command` interface. As an example, here is how
to override the `clear` command:
+
====
[source, java]
----
public class MyClear implements Clear.Command {

    @ShellMethod("Clear the screen, only better.")
    public void clear() {
        // ...
    }
}
----
====

[NOTE]
.Please Consider Contributing your Changes
====
If you feel like your implementation of a standard command could be valuable to the community,
please open a pull-request at https://github.com/spring-projects/spring-shell.

Alternatively, before making any changes on your own, you can open an issue with the project. Feedback is
always welcome!
====

// ==== ResultHandlers

// TBD

==== PromptProvider
After each command invocation, the shell waits for new input from the user, displaying
a prompt in yellow:

====
[source]
----
shell:>
----
====

It is possible to customize this behavior by registering a bean of type `PromptProvider`.
Such a bean may use internal state to decide what to display to the user (it may, for example,
react to https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#context-functionality-events-annotation[application events])
and can use JLine's `AttributedCharSequence` to display fancy ANSI text.

The following example shows how to use a `PromptProvider`:

====
[source, java]
----
@Component
public class CustomPromptProvider implements PromptProvider {

	private ConnectionDetails connection;

	@Override
	public AttributedString getPrompt() {
		if (connection != null) {
			return new AttributedString(connection.getHost() + ":>",
				AttributedStyle.DEFAULT.foreground(AttributedStyle.YELLOW));
		}
		else {
			return new AttributedString("server-unknown:>",
				AttributedStyle.DEFAULT.foreground(AttributedStyle.RED));
		}
	}

	@EventListener
	public void handle(ConnectionUpdatedEvent event) {
		this.connection = event.getConnectionDetails();
	}
}
----
====

==== Customizing Command Line Options Behavior

There can be exactly one shell spesific `ShellApplicationRunner` which simply extends
Boot's `ApplicationRunner`. Default behariour is to have actual runner logic in
various `ShellRunner` implementations where candidate will be picked up.

[IMPORTANT]
====
This is a breaking change in `2.1.x` as previous shell versions had an confusing
logic how `ApplicationRunner` instances were used. These changes were made
to have a better support for interactive and non-interactive modes in a same
shell application as it's convenient to fully work on command-line and still
have ability to enter interactive mode.

You can override bean type of `ShellApplicationRunner` if there's a need to
customise shell running logic.
====

==== Customizing Arguments Conversion

Conversion from text input to actual method arguments uses the standard Spring
https://docs.spring.io/spring/docs/4.3.11.RELEASE/spring-framework-reference/htmlsingle/#core-convert[conversion] mechanism.
Spring Shell installs a new `DefaultConversionService` (with built-in converters enabled)
and registers to it any bean of type `Converter<S, T>`, `GenericConverter`, or
`ConverterFactory<S, T>` that it finds in the application context.

This means that you can customize conversion to your custom objects
by installing a `Converter<String, Foo>` bean in the context:

====
[source, java]
----
@ShellComponent
class ConversionCommands {

	@ShellMethod("Shows conversion using Spring converter")
	public String conversionExample(DomainObject object) {
		return object.getClass();
	}

}

class DomainObject {
	private final String value;

	DomainObject(String value) {
		this.value = value;
	}

	public String toString() {
		return value;
	}
}

@Component
class CustomDomainConverter implements Converter<String, DomainObject> {

	@Override
	public DomainObject convert(String source) {
		return new DomainObject(source);
	}
}

----
====

[TIP]
.Mind your String representation
=====
As in the preceding example, you should have
your `toString()` implementations return the converse of what was used
to create the object instance. This is because, when a value fails
validation, Spring Shell prints:

====
[source]
----
The following constraints were not met:
	--arg <type> : <message> (You passed '<value.toString()>')
----
====

See <<validating-command-arguments>> for more information.
=====

[NOTE]
====
If you want to customize the `ConversionService` further, you can:

* Have the default one injected in your code and act upon it in some way.
* Override it altogether with your own (custom converters need to be registered by hand).
  The `ConversionService` used by Spring Shell needs to be https://docs.spring.io/spring/docs/4.3.12.RELEASE/spring-framework-reference/htmlsingle/#beans-autowired-annotation-qualifiers[qualified] as `"spring-shell"`.
====
