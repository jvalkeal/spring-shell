// Generated by jextract

package org.springframework.shell.treesitter.ts;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class TreeSitter {

    TreeSitter() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int TREE_SITTER_LANGUAGE_VERSION = (int)14L;
    /**
     * {@snippet lang=c :
     * #define TREE_SITTER_LANGUAGE_VERSION 14
     * }
     */
    public static int TREE_SITTER_LANGUAGE_VERSION() {
        return TREE_SITTER_LANGUAGE_VERSION;
    }
    private static final int TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION = (int)13L;
    /**
     * {@snippet lang=c :
     * #define TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION 13
     * }
     */
    public static int TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION() {
        return TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION;
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static void free(MemorySegment __ptr) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", __ptr);
            }
            mh$.invokeExact(__ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int TSInputEncodingUTF8 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum TSInputEncoding.TSInputEncodingUTF8 = 0
     * }
     */
    public static int TSInputEncodingUTF8() {
        return TSInputEncodingUTF8;
    }
    private static final int TSInputEncodingUTF16 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum TSInputEncoding.TSInputEncodingUTF16 = 1
     * }
     */
    public static int TSInputEncodingUTF16() {
        return TSInputEncodingUTF16;
    }
    private static final int TSSymbolTypeRegular = (int)0L;
    /**
     * {@snippet lang=c :
     * enum TSSymbolType.TSSymbolTypeRegular = 0
     * }
     */
    public static int TSSymbolTypeRegular() {
        return TSSymbolTypeRegular;
    }
    private static final int TSSymbolTypeAnonymous = (int)1L;
    /**
     * {@snippet lang=c :
     * enum TSSymbolType.TSSymbolTypeAnonymous = 1
     * }
     */
    public static int TSSymbolTypeAnonymous() {
        return TSSymbolTypeAnonymous;
    }
    private static final int TSSymbolTypeAuxiliary = (int)2L;
    /**
     * {@snippet lang=c :
     * enum TSSymbolType.TSSymbolTypeAuxiliary = 2
     * }
     */
    public static int TSSymbolTypeAuxiliary() {
        return TSSymbolTypeAuxiliary;
    }
    private static final int TSLogTypeParse = (int)0L;
    /**
     * {@snippet lang=c :
     * enum TSLogType.TSLogTypeParse = 0
     * }
     */
    public static int TSLogTypeParse() {
        return TSLogTypeParse;
    }
    private static final int TSLogTypeLex = (int)1L;
    /**
     * {@snippet lang=c :
     * enum TSLogType.TSLogTypeLex = 1
     * }
     */
    public static int TSLogTypeLex() {
        return TSLogTypeLex;
    }
    private static final int TSQuantifierZero = (int)0L;
    /**
     * {@snippet lang=c :
     * enum TSQuantifier.TSQuantifierZero = 0
     * }
     */
    public static int TSQuantifierZero() {
        return TSQuantifierZero;
    }
    private static final int TSQuantifierZeroOrOne = (int)1L;
    /**
     * {@snippet lang=c :
     * enum TSQuantifier.TSQuantifierZeroOrOne = 1
     * }
     */
    public static int TSQuantifierZeroOrOne() {
        return TSQuantifierZeroOrOne;
    }
    private static final int TSQuantifierZeroOrMore = (int)2L;
    /**
     * {@snippet lang=c :
     * enum TSQuantifier.TSQuantifierZeroOrMore = 2
     * }
     */
    public static int TSQuantifierZeroOrMore() {
        return TSQuantifierZeroOrMore;
    }
    private static final int TSQuantifierOne = (int)3L;
    /**
     * {@snippet lang=c :
     * enum TSQuantifier.TSQuantifierOne = 3
     * }
     */
    public static int TSQuantifierOne() {
        return TSQuantifierOne;
    }
    private static final int TSQuantifierOneOrMore = (int)4L;
    /**
     * {@snippet lang=c :
     * enum TSQuantifier.TSQuantifierOneOrMore = 4
     * }
     */
    public static int TSQuantifierOneOrMore() {
        return TSQuantifierOneOrMore;
    }
    private static final int TSQueryPredicateStepTypeDone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum TSQueryPredicateStepType.TSQueryPredicateStepTypeDone = 0
     * }
     */
    public static int TSQueryPredicateStepTypeDone() {
        return TSQueryPredicateStepTypeDone;
    }
    private static final int TSQueryPredicateStepTypeCapture = (int)1L;
    /**
     * {@snippet lang=c :
     * enum TSQueryPredicateStepType.TSQueryPredicateStepTypeCapture = 1
     * }
     */
    public static int TSQueryPredicateStepTypeCapture() {
        return TSQueryPredicateStepTypeCapture;
    }
    private static final int TSQueryPredicateStepTypeString = (int)2L;
    /**
     * {@snippet lang=c :
     * enum TSQueryPredicateStepType.TSQueryPredicateStepTypeString = 2
     * }
     */
    public static int TSQueryPredicateStepTypeString() {
        return TSQueryPredicateStepTypeString;
    }
    private static final int TSQueryErrorNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum TSQueryError.TSQueryErrorNone = 0
     * }
     */
    public static int TSQueryErrorNone() {
        return TSQueryErrorNone;
    }
    private static final int TSQueryErrorSyntax = (int)1L;
    /**
     * {@snippet lang=c :
     * enum TSQueryError.TSQueryErrorSyntax = 1
     * }
     */
    public static int TSQueryErrorSyntax() {
        return TSQueryErrorSyntax;
    }
    private static final int TSQueryErrorNodeType = (int)2L;
    /**
     * {@snippet lang=c :
     * enum TSQueryError.TSQueryErrorNodeType = 2
     * }
     */
    public static int TSQueryErrorNodeType() {
        return TSQueryErrorNodeType;
    }
    private static final int TSQueryErrorField = (int)3L;
    /**
     * {@snippet lang=c :
     * enum TSQueryError.TSQueryErrorField = 3
     * }
     */
    public static int TSQueryErrorField() {
        return TSQueryErrorField;
    }
    private static final int TSQueryErrorCapture = (int)4L;
    /**
     * {@snippet lang=c :
     * enum TSQueryError.TSQueryErrorCapture = 4
     * }
     */
    public static int TSQueryErrorCapture() {
        return TSQueryErrorCapture;
    }
    private static final int TSQueryErrorStructure = (int)5L;
    /**
     * {@snippet lang=c :
     * enum TSQueryError.TSQueryErrorStructure = 5
     * }
     */
    public static int TSQueryErrorStructure() {
        return TSQueryErrorStructure;
    }
    private static final int TSQueryErrorLanguage = (int)6L;
    /**
     * {@snippet lang=c :
     * enum TSQueryError.TSQueryErrorLanguage = 6
     * }
     */
    public static int TSQueryErrorLanguage() {
        return TSQueryErrorLanguage;
    }

    private static class ts_parser_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER    );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSParser *ts_parser_new()
     * }
     */
    public static FunctionDescriptor ts_parser_new$descriptor() {
        return ts_parser_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSParser *ts_parser_new()
     * }
     */
    public static MethodHandle ts_parser_new$handle() {
        return ts_parser_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSParser *ts_parser_new()
     * }
     */
    public static MemorySegment ts_parser_new$address() {
        return ts_parser_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSParser *ts_parser_new()
     * }
     */
    public static MemorySegment ts_parser_new() {
        var mh$ = ts_parser_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_parser_delete(TSParser *self)
     * }
     */
    public static FunctionDescriptor ts_parser_delete$descriptor() {
        return ts_parser_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_parser_delete(TSParser *self)
     * }
     */
    public static MethodHandle ts_parser_delete$handle() {
        return ts_parser_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_parser_delete(TSParser *self)
     * }
     */
    public static MemorySegment ts_parser_delete$address() {
        return ts_parser_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_parser_delete(TSParser *self)
     * }
     */
    public static void ts_parser_delete(MemorySegment self) {
        var mh$ = ts_parser_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_delete", self);
            }
            mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_language {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_language");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const TSLanguage *ts_parser_language(const TSParser *self)
     * }
     */
    public static FunctionDescriptor ts_parser_language$descriptor() {
        return ts_parser_language.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const TSLanguage *ts_parser_language(const TSParser *self)
     * }
     */
    public static MethodHandle ts_parser_language$handle() {
        return ts_parser_language.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const TSLanguage *ts_parser_language(const TSParser *self)
     * }
     */
    public static MemorySegment ts_parser_language$address() {
        return ts_parser_language.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const TSLanguage *ts_parser_language(const TSParser *self)
     * }
     */
    public static MemorySegment ts_parser_language(MemorySegment self) {
        var mh$ = ts_parser_language.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_language", self);
            }
            return (MemorySegment)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_set_language {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_set_language");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_parser_set_language(TSParser *self, const TSLanguage *language)
     * }
     */
    public static FunctionDescriptor ts_parser_set_language$descriptor() {
        return ts_parser_set_language.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_parser_set_language(TSParser *self, const TSLanguage *language)
     * }
     */
    public static MethodHandle ts_parser_set_language$handle() {
        return ts_parser_set_language.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_parser_set_language(TSParser *self, const TSLanguage *language)
     * }
     */
    public static MemorySegment ts_parser_set_language$address() {
        return ts_parser_set_language.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_parser_set_language(TSParser *self, const TSLanguage *language)
     * }
     */
    public static boolean ts_parser_set_language(MemorySegment self, MemorySegment language) {
        var mh$ = ts_parser_set_language.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_set_language", self, language);
            }
            return (boolean)mh$.invokeExact(self, language);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_set_included_ranges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_set_included_ranges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_parser_set_included_ranges(TSParser *self, const TSRange *ranges, uint32_t count)
     * }
     */
    public static FunctionDescriptor ts_parser_set_included_ranges$descriptor() {
        return ts_parser_set_included_ranges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_parser_set_included_ranges(TSParser *self, const TSRange *ranges, uint32_t count)
     * }
     */
    public static MethodHandle ts_parser_set_included_ranges$handle() {
        return ts_parser_set_included_ranges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_parser_set_included_ranges(TSParser *self, const TSRange *ranges, uint32_t count)
     * }
     */
    public static MemorySegment ts_parser_set_included_ranges$address() {
        return ts_parser_set_included_ranges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_parser_set_included_ranges(TSParser *self, const TSRange *ranges, uint32_t count)
     * }
     */
    public static boolean ts_parser_set_included_ranges(MemorySegment self, MemorySegment ranges, int count) {
        var mh$ = ts_parser_set_included_ranges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_set_included_ranges", self, ranges, count);
            }
            return (boolean)mh$.invokeExact(self, ranges, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_included_ranges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_included_ranges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const TSRange *ts_parser_included_ranges(const TSParser *self, uint32_t *count)
     * }
     */
    public static FunctionDescriptor ts_parser_included_ranges$descriptor() {
        return ts_parser_included_ranges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const TSRange *ts_parser_included_ranges(const TSParser *self, uint32_t *count)
     * }
     */
    public static MethodHandle ts_parser_included_ranges$handle() {
        return ts_parser_included_ranges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const TSRange *ts_parser_included_ranges(const TSParser *self, uint32_t *count)
     * }
     */
    public static MemorySegment ts_parser_included_ranges$address() {
        return ts_parser_included_ranges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const TSRange *ts_parser_included_ranges(const TSParser *self, uint32_t *count)
     * }
     */
    public static MemorySegment ts_parser_included_ranges(MemorySegment self, MemorySegment count) {
        var mh$ = ts_parser_included_ranges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_included_ranges", self, count);
            }
            return (MemorySegment)mh$.invokeExact(self, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TSInput.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSTree *ts_parser_parse(TSParser *self, const TSTree *old_tree, TSInput input)
     * }
     */
    public static FunctionDescriptor ts_parser_parse$descriptor() {
        return ts_parser_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSTree *ts_parser_parse(TSParser *self, const TSTree *old_tree, TSInput input)
     * }
     */
    public static MethodHandle ts_parser_parse$handle() {
        return ts_parser_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSTree *ts_parser_parse(TSParser *self, const TSTree *old_tree, TSInput input)
     * }
     */
    public static MemorySegment ts_parser_parse$address() {
        return ts_parser_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSTree *ts_parser_parse(TSParser *self, const TSTree *old_tree, TSInput input)
     * }
     */
    public static MemorySegment ts_parser_parse(MemorySegment self, MemorySegment old_tree, MemorySegment input) {
        var mh$ = ts_parser_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_parse", self, old_tree, input);
            }
            return (MemorySegment)mh$.invokeExact(self, old_tree, input);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_parse_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_parse_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSTree *ts_parser_parse_string(TSParser *self, const TSTree *old_tree, const char *string, uint32_t length)
     * }
     */
    public static FunctionDescriptor ts_parser_parse_string$descriptor() {
        return ts_parser_parse_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSTree *ts_parser_parse_string(TSParser *self, const TSTree *old_tree, const char *string, uint32_t length)
     * }
     */
    public static MethodHandle ts_parser_parse_string$handle() {
        return ts_parser_parse_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSTree *ts_parser_parse_string(TSParser *self, const TSTree *old_tree, const char *string, uint32_t length)
     * }
     */
    public static MemorySegment ts_parser_parse_string$address() {
        return ts_parser_parse_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSTree *ts_parser_parse_string(TSParser *self, const TSTree *old_tree, const char *string, uint32_t length)
     * }
     */
    public static MemorySegment ts_parser_parse_string(MemorySegment self, MemorySegment old_tree, MemorySegment string, int length) {
        var mh$ = ts_parser_parse_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_parse_string", self, old_tree, string, length);
            }
            return (MemorySegment)mh$.invokeExact(self, old_tree, string, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_parse_string_encoding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_parse_string_encoding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSTree *ts_parser_parse_string_encoding(TSParser *self, const TSTree *old_tree, const char *string, uint32_t length, TSInputEncoding encoding)
     * }
     */
    public static FunctionDescriptor ts_parser_parse_string_encoding$descriptor() {
        return ts_parser_parse_string_encoding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSTree *ts_parser_parse_string_encoding(TSParser *self, const TSTree *old_tree, const char *string, uint32_t length, TSInputEncoding encoding)
     * }
     */
    public static MethodHandle ts_parser_parse_string_encoding$handle() {
        return ts_parser_parse_string_encoding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSTree *ts_parser_parse_string_encoding(TSParser *self, const TSTree *old_tree, const char *string, uint32_t length, TSInputEncoding encoding)
     * }
     */
    public static MemorySegment ts_parser_parse_string_encoding$address() {
        return ts_parser_parse_string_encoding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSTree *ts_parser_parse_string_encoding(TSParser *self, const TSTree *old_tree, const char *string, uint32_t length, TSInputEncoding encoding)
     * }
     */
    public static MemorySegment ts_parser_parse_string_encoding(MemorySegment self, MemorySegment old_tree, MemorySegment string, int length, int encoding) {
        var mh$ = ts_parser_parse_string_encoding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_parse_string_encoding", self, old_tree, string, length, encoding);
            }
            return (MemorySegment)mh$.invokeExact(self, old_tree, string, length, encoding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_parser_reset(TSParser *self)
     * }
     */
    public static FunctionDescriptor ts_parser_reset$descriptor() {
        return ts_parser_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_parser_reset(TSParser *self)
     * }
     */
    public static MethodHandle ts_parser_reset$handle() {
        return ts_parser_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_parser_reset(TSParser *self)
     * }
     */
    public static MemorySegment ts_parser_reset$address() {
        return ts_parser_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_parser_reset(TSParser *self)
     * }
     */
    public static void ts_parser_reset(MemorySegment self) {
        var mh$ = ts_parser_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_reset", self);
            }
            mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_set_timeout_micros {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_LONG
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_set_timeout_micros");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_parser_set_timeout_micros(TSParser *self, uint64_t timeout_micros)
     * }
     */
    public static FunctionDescriptor ts_parser_set_timeout_micros$descriptor() {
        return ts_parser_set_timeout_micros.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_parser_set_timeout_micros(TSParser *self, uint64_t timeout_micros)
     * }
     */
    public static MethodHandle ts_parser_set_timeout_micros$handle() {
        return ts_parser_set_timeout_micros.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_parser_set_timeout_micros(TSParser *self, uint64_t timeout_micros)
     * }
     */
    public static MemorySegment ts_parser_set_timeout_micros$address() {
        return ts_parser_set_timeout_micros.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_parser_set_timeout_micros(TSParser *self, uint64_t timeout_micros)
     * }
     */
    public static void ts_parser_set_timeout_micros(MemorySegment self, long timeout_micros) {
        var mh$ = ts_parser_set_timeout_micros.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_set_timeout_micros", self, timeout_micros);
            }
            mh$.invokeExact(self, timeout_micros);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_timeout_micros {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_LONG,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_timeout_micros");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t ts_parser_timeout_micros(const TSParser *self)
     * }
     */
    public static FunctionDescriptor ts_parser_timeout_micros$descriptor() {
        return ts_parser_timeout_micros.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t ts_parser_timeout_micros(const TSParser *self)
     * }
     */
    public static MethodHandle ts_parser_timeout_micros$handle() {
        return ts_parser_timeout_micros.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t ts_parser_timeout_micros(const TSParser *self)
     * }
     */
    public static MemorySegment ts_parser_timeout_micros$address() {
        return ts_parser_timeout_micros.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t ts_parser_timeout_micros(const TSParser *self)
     * }
     */
    public static long ts_parser_timeout_micros(MemorySegment self) {
        var mh$ = ts_parser_timeout_micros.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_timeout_micros", self);
            }
            return (long)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_set_cancellation_flag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_set_cancellation_flag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_parser_set_cancellation_flag(TSParser *self, const size_t *flag)
     * }
     */
    public static FunctionDescriptor ts_parser_set_cancellation_flag$descriptor() {
        return ts_parser_set_cancellation_flag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_parser_set_cancellation_flag(TSParser *self, const size_t *flag)
     * }
     */
    public static MethodHandle ts_parser_set_cancellation_flag$handle() {
        return ts_parser_set_cancellation_flag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_parser_set_cancellation_flag(TSParser *self, const size_t *flag)
     * }
     */
    public static MemorySegment ts_parser_set_cancellation_flag$address() {
        return ts_parser_set_cancellation_flag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_parser_set_cancellation_flag(TSParser *self, const size_t *flag)
     * }
     */
    public static void ts_parser_set_cancellation_flag(MemorySegment self, MemorySegment flag) {
        var mh$ = ts_parser_set_cancellation_flag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_set_cancellation_flag", self, flag);
            }
            mh$.invokeExact(self, flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_cancellation_flag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_cancellation_flag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const size_t *ts_parser_cancellation_flag(const TSParser *self)
     * }
     */
    public static FunctionDescriptor ts_parser_cancellation_flag$descriptor() {
        return ts_parser_cancellation_flag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const size_t *ts_parser_cancellation_flag(const TSParser *self)
     * }
     */
    public static MethodHandle ts_parser_cancellation_flag$handle() {
        return ts_parser_cancellation_flag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const size_t *ts_parser_cancellation_flag(const TSParser *self)
     * }
     */
    public static MemorySegment ts_parser_cancellation_flag$address() {
        return ts_parser_cancellation_flag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const size_t *ts_parser_cancellation_flag(const TSParser *self)
     * }
     */
    public static MemorySegment ts_parser_cancellation_flag(MemorySegment self) {
        var mh$ = ts_parser_cancellation_flag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_cancellation_flag", self);
            }
            return (MemorySegment)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_set_logger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TSLogger.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_set_logger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_parser_set_logger(TSParser *self, TSLogger logger)
     * }
     */
    public static FunctionDescriptor ts_parser_set_logger$descriptor() {
        return ts_parser_set_logger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_parser_set_logger(TSParser *self, TSLogger logger)
     * }
     */
    public static MethodHandle ts_parser_set_logger$handle() {
        return ts_parser_set_logger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_parser_set_logger(TSParser *self, TSLogger logger)
     * }
     */
    public static MemorySegment ts_parser_set_logger$address() {
        return ts_parser_set_logger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_parser_set_logger(TSParser *self, TSLogger logger)
     * }
     */
    public static void ts_parser_set_logger(MemorySegment self, MemorySegment logger) {
        var mh$ = ts_parser_set_logger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_set_logger", self, logger);
            }
            mh$.invokeExact(self, logger);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_logger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSLogger.layout(),
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_logger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSLogger ts_parser_logger(const TSParser *self)
     * }
     */
    public static FunctionDescriptor ts_parser_logger$descriptor() {
        return ts_parser_logger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSLogger ts_parser_logger(const TSParser *self)
     * }
     */
    public static MethodHandle ts_parser_logger$handle() {
        return ts_parser_logger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSLogger ts_parser_logger(const TSParser *self)
     * }
     */
    public static MemorySegment ts_parser_logger$address() {
        return ts_parser_logger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSLogger ts_parser_logger(const TSParser *self)
     * }
     */
    public static MemorySegment ts_parser_logger(SegmentAllocator allocator, MemorySegment self) {
        var mh$ = ts_parser_logger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_logger", allocator, self);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_parser_print_dot_graphs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_parser_print_dot_graphs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_parser_print_dot_graphs(TSParser *self, int fd)
     * }
     */
    public static FunctionDescriptor ts_parser_print_dot_graphs$descriptor() {
        return ts_parser_print_dot_graphs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_parser_print_dot_graphs(TSParser *self, int fd)
     * }
     */
    public static MethodHandle ts_parser_print_dot_graphs$handle() {
        return ts_parser_print_dot_graphs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_parser_print_dot_graphs(TSParser *self, int fd)
     * }
     */
    public static MemorySegment ts_parser_print_dot_graphs$address() {
        return ts_parser_print_dot_graphs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_parser_print_dot_graphs(TSParser *self, int fd)
     * }
     */
    public static void ts_parser_print_dot_graphs(MemorySegment self, int fd) {
        var mh$ = ts_parser_print_dot_graphs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_parser_print_dot_graphs", self, fd);
            }
            mh$.invokeExact(self, fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSTree *ts_tree_copy(const TSTree *self)
     * }
     */
    public static FunctionDescriptor ts_tree_copy$descriptor() {
        return ts_tree_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSTree *ts_tree_copy(const TSTree *self)
     * }
     */
    public static MethodHandle ts_tree_copy$handle() {
        return ts_tree_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSTree *ts_tree_copy(const TSTree *self)
     * }
     */
    public static MemorySegment ts_tree_copy$address() {
        return ts_tree_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSTree *ts_tree_copy(const TSTree *self)
     * }
     */
    public static MemorySegment ts_tree_copy(MemorySegment self) {
        var mh$ = ts_tree_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_copy", self);
            }
            return (MemorySegment)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_tree_delete(TSTree *self)
     * }
     */
    public static FunctionDescriptor ts_tree_delete$descriptor() {
        return ts_tree_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_tree_delete(TSTree *self)
     * }
     */
    public static MethodHandle ts_tree_delete$handle() {
        return ts_tree_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_tree_delete(TSTree *self)
     * }
     */
    public static MemorySegment ts_tree_delete$address() {
        return ts_tree_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_tree_delete(TSTree *self)
     * }
     */
    public static void ts_tree_delete(MemorySegment self) {
        var mh$ = ts_tree_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_delete", self);
            }
            mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_root_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_root_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_tree_root_node(const TSTree *self)
     * }
     */
    public static FunctionDescriptor ts_tree_root_node$descriptor() {
        return ts_tree_root_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_tree_root_node(const TSTree *self)
     * }
     */
    public static MethodHandle ts_tree_root_node$handle() {
        return ts_tree_root_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_tree_root_node(const TSTree *self)
     * }
     */
    public static MemorySegment ts_tree_root_node$address() {
        return ts_tree_root_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_tree_root_node(const TSTree *self)
     * }
     */
    public static MemorySegment ts_tree_root_node(SegmentAllocator allocator, MemorySegment self) {
        var mh$ = ts_tree_root_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_root_node", allocator, self);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_root_node_with_offset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TreeSitter.C_POINTER,
            TreeSitter.C_INT,
            TSPoint.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_root_node_with_offset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_tree_root_node_with_offset(const TSTree *self, uint32_t offset_bytes, TSPoint offset_extent)
     * }
     */
    public static FunctionDescriptor ts_tree_root_node_with_offset$descriptor() {
        return ts_tree_root_node_with_offset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_tree_root_node_with_offset(const TSTree *self, uint32_t offset_bytes, TSPoint offset_extent)
     * }
     */
    public static MethodHandle ts_tree_root_node_with_offset$handle() {
        return ts_tree_root_node_with_offset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_tree_root_node_with_offset(const TSTree *self, uint32_t offset_bytes, TSPoint offset_extent)
     * }
     */
    public static MemorySegment ts_tree_root_node_with_offset$address() {
        return ts_tree_root_node_with_offset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_tree_root_node_with_offset(const TSTree *self, uint32_t offset_bytes, TSPoint offset_extent)
     * }
     */
    public static MemorySegment ts_tree_root_node_with_offset(SegmentAllocator allocator, MemorySegment self, int offset_bytes, MemorySegment offset_extent) {
        var mh$ = ts_tree_root_node_with_offset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_root_node_with_offset", allocator, self, offset_bytes, offset_extent);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self, offset_bytes, offset_extent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_language {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_language");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const TSLanguage *ts_tree_language(const TSTree *self)
     * }
     */
    public static FunctionDescriptor ts_tree_language$descriptor() {
        return ts_tree_language.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const TSLanguage *ts_tree_language(const TSTree *self)
     * }
     */
    public static MethodHandle ts_tree_language$handle() {
        return ts_tree_language.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const TSLanguage *ts_tree_language(const TSTree *self)
     * }
     */
    public static MemorySegment ts_tree_language$address() {
        return ts_tree_language.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const TSLanguage *ts_tree_language(const TSTree *self)
     * }
     */
    public static MemorySegment ts_tree_language(MemorySegment self) {
        var mh$ = ts_tree_language.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_language", self);
            }
            return (MemorySegment)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_included_ranges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_included_ranges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSRange *ts_tree_included_ranges(const TSTree *self, uint32_t *length)
     * }
     */
    public static FunctionDescriptor ts_tree_included_ranges$descriptor() {
        return ts_tree_included_ranges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSRange *ts_tree_included_ranges(const TSTree *self, uint32_t *length)
     * }
     */
    public static MethodHandle ts_tree_included_ranges$handle() {
        return ts_tree_included_ranges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSRange *ts_tree_included_ranges(const TSTree *self, uint32_t *length)
     * }
     */
    public static MemorySegment ts_tree_included_ranges$address() {
        return ts_tree_included_ranges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSRange *ts_tree_included_ranges(const TSTree *self, uint32_t *length)
     * }
     */
    public static MemorySegment ts_tree_included_ranges(MemorySegment self, MemorySegment length) {
        var mh$ = ts_tree_included_ranges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_included_ranges", self, length);
            }
            return (MemorySegment)mh$.invokeExact(self, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_edit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_edit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_tree_edit(TSTree *self, const TSInputEdit *edit)
     * }
     */
    public static FunctionDescriptor ts_tree_edit$descriptor() {
        return ts_tree_edit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_tree_edit(TSTree *self, const TSInputEdit *edit)
     * }
     */
    public static MethodHandle ts_tree_edit$handle() {
        return ts_tree_edit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_tree_edit(TSTree *self, const TSInputEdit *edit)
     * }
     */
    public static MemorySegment ts_tree_edit$address() {
        return ts_tree_edit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_tree_edit(TSTree *self, const TSInputEdit *edit)
     * }
     */
    public static void ts_tree_edit(MemorySegment self, MemorySegment edit) {
        var mh$ = ts_tree_edit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_edit", self, edit);
            }
            mh$.invokeExact(self, edit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_get_changed_ranges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_get_changed_ranges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSRange *ts_tree_get_changed_ranges(const TSTree *old_tree, const TSTree *new_tree, uint32_t *length)
     * }
     */
    public static FunctionDescriptor ts_tree_get_changed_ranges$descriptor() {
        return ts_tree_get_changed_ranges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSRange *ts_tree_get_changed_ranges(const TSTree *old_tree, const TSTree *new_tree, uint32_t *length)
     * }
     */
    public static MethodHandle ts_tree_get_changed_ranges$handle() {
        return ts_tree_get_changed_ranges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSRange *ts_tree_get_changed_ranges(const TSTree *old_tree, const TSTree *new_tree, uint32_t *length)
     * }
     */
    public static MemorySegment ts_tree_get_changed_ranges$address() {
        return ts_tree_get_changed_ranges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSRange *ts_tree_get_changed_ranges(const TSTree *old_tree, const TSTree *new_tree, uint32_t *length)
     * }
     */
    public static MemorySegment ts_tree_get_changed_ranges(MemorySegment old_tree, MemorySegment new_tree, MemorySegment length) {
        var mh$ = ts_tree_get_changed_ranges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_get_changed_ranges", old_tree, new_tree, length);
            }
            return (MemorySegment)mh$.invokeExact(old_tree, new_tree, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_print_dot_graph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_print_dot_graph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_tree_print_dot_graph(const TSTree *self, int file_descriptor)
     * }
     */
    public static FunctionDescriptor ts_tree_print_dot_graph$descriptor() {
        return ts_tree_print_dot_graph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_tree_print_dot_graph(const TSTree *self, int file_descriptor)
     * }
     */
    public static MethodHandle ts_tree_print_dot_graph$handle() {
        return ts_tree_print_dot_graph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_tree_print_dot_graph(const TSTree *self, int file_descriptor)
     * }
     */
    public static MemorySegment ts_tree_print_dot_graph$address() {
        return ts_tree_print_dot_graph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_tree_print_dot_graph(const TSTree *self, int file_descriptor)
     * }
     */
    public static void ts_tree_print_dot_graph(MemorySegment self, int file_descriptor) {
        var mh$ = ts_tree_print_dot_graph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_print_dot_graph", self, file_descriptor);
            }
            mh$.invokeExact(self, file_descriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ts_node_type(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_type$descriptor() {
        return ts_node_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ts_node_type(TSNode self)
     * }
     */
    public static MethodHandle ts_node_type$handle() {
        return ts_node_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ts_node_type(TSNode self)
     * }
     */
    public static MemorySegment ts_node_type$address() {
        return ts_node_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ts_node_type(TSNode self)
     * }
     */
    public static MemorySegment ts_node_type(MemorySegment self) {
        var mh$ = ts_node_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_type", self);
            }
            return (MemorySegment)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_SHORT,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSSymbol ts_node_symbol(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_symbol$descriptor() {
        return ts_node_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSSymbol ts_node_symbol(TSNode self)
     * }
     */
    public static MethodHandle ts_node_symbol$handle() {
        return ts_node_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSSymbol ts_node_symbol(TSNode self)
     * }
     */
    public static MemorySegment ts_node_symbol$address() {
        return ts_node_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSSymbol ts_node_symbol(TSNode self)
     * }
     */
    public static short ts_node_symbol(MemorySegment self) {
        var mh$ = ts_node_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_symbol", self);
            }
            return (short)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_language {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_language");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const TSLanguage *ts_node_language(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_language$descriptor() {
        return ts_node_language.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const TSLanguage *ts_node_language(TSNode self)
     * }
     */
    public static MethodHandle ts_node_language$handle() {
        return ts_node_language.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const TSLanguage *ts_node_language(TSNode self)
     * }
     */
    public static MemorySegment ts_node_language$address() {
        return ts_node_language.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const TSLanguage *ts_node_language(TSNode self)
     * }
     */
    public static MemorySegment ts_node_language(MemorySegment self) {
        var mh$ = ts_node_language.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_language", self);
            }
            return (MemorySegment)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_grammar_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_grammar_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ts_node_grammar_type(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_grammar_type$descriptor() {
        return ts_node_grammar_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ts_node_grammar_type(TSNode self)
     * }
     */
    public static MethodHandle ts_node_grammar_type$handle() {
        return ts_node_grammar_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ts_node_grammar_type(TSNode self)
     * }
     */
    public static MemorySegment ts_node_grammar_type$address() {
        return ts_node_grammar_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ts_node_grammar_type(TSNode self)
     * }
     */
    public static MemorySegment ts_node_grammar_type(MemorySegment self) {
        var mh$ = ts_node_grammar_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_grammar_type", self);
            }
            return (MemorySegment)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_grammar_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_SHORT,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_grammar_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSSymbol ts_node_grammar_symbol(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_grammar_symbol$descriptor() {
        return ts_node_grammar_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSSymbol ts_node_grammar_symbol(TSNode self)
     * }
     */
    public static MethodHandle ts_node_grammar_symbol$handle() {
        return ts_node_grammar_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSSymbol ts_node_grammar_symbol(TSNode self)
     * }
     */
    public static MemorySegment ts_node_grammar_symbol$address() {
        return ts_node_grammar_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSSymbol ts_node_grammar_symbol(TSNode self)
     * }
     */
    public static short ts_node_grammar_symbol(MemorySegment self) {
        var mh$ = ts_node_grammar_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_grammar_symbol", self);
            }
            return (short)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_start_byte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_start_byte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_node_start_byte(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_start_byte$descriptor() {
        return ts_node_start_byte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_node_start_byte(TSNode self)
     * }
     */
    public static MethodHandle ts_node_start_byte$handle() {
        return ts_node_start_byte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_node_start_byte(TSNode self)
     * }
     */
    public static MemorySegment ts_node_start_byte$address() {
        return ts_node_start_byte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_node_start_byte(TSNode self)
     * }
     */
    public static int ts_node_start_byte(MemorySegment self) {
        var mh$ = ts_node_start_byte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_start_byte", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_start_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSPoint.layout(),
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_start_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSPoint ts_node_start_point(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_start_point$descriptor() {
        return ts_node_start_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSPoint ts_node_start_point(TSNode self)
     * }
     */
    public static MethodHandle ts_node_start_point$handle() {
        return ts_node_start_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSPoint ts_node_start_point(TSNode self)
     * }
     */
    public static MemorySegment ts_node_start_point$address() {
        return ts_node_start_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSPoint ts_node_start_point(TSNode self)
     * }
     */
    public static MemorySegment ts_node_start_point(SegmentAllocator allocator, MemorySegment self) {
        var mh$ = ts_node_start_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_start_point", allocator, self);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_end_byte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_end_byte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_node_end_byte(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_end_byte$descriptor() {
        return ts_node_end_byte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_node_end_byte(TSNode self)
     * }
     */
    public static MethodHandle ts_node_end_byte$handle() {
        return ts_node_end_byte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_node_end_byte(TSNode self)
     * }
     */
    public static MemorySegment ts_node_end_byte$address() {
        return ts_node_end_byte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_node_end_byte(TSNode self)
     * }
     */
    public static int ts_node_end_byte(MemorySegment self) {
        var mh$ = ts_node_end_byte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_end_byte", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_end_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSPoint.layout(),
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_end_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSPoint ts_node_end_point(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_end_point$descriptor() {
        return ts_node_end_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSPoint ts_node_end_point(TSNode self)
     * }
     */
    public static MethodHandle ts_node_end_point$handle() {
        return ts_node_end_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSPoint ts_node_end_point(TSNode self)
     * }
     */
    public static MemorySegment ts_node_end_point$address() {
        return ts_node_end_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSPoint ts_node_end_point(TSNode self)
     * }
     */
    public static MemorySegment ts_node_end_point(SegmentAllocator allocator, MemorySegment self) {
        var mh$ = ts_node_end_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_end_point", allocator, self);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ts_node_string(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_string$descriptor() {
        return ts_node_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ts_node_string(TSNode self)
     * }
     */
    public static MethodHandle ts_node_string$handle() {
        return ts_node_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ts_node_string(TSNode self)
     * }
     */
    public static MemorySegment ts_node_string$address() {
        return ts_node_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ts_node_string(TSNode self)
     * }
     */
    public static MemorySegment ts_node_string(MemorySegment self) {
        var mh$ = ts_node_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_string", self);
            }
            return (MemorySegment)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_is_null {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_is_null");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_node_is_null(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_is_null$descriptor() {
        return ts_node_is_null.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_node_is_null(TSNode self)
     * }
     */
    public static MethodHandle ts_node_is_null$handle() {
        return ts_node_is_null.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_node_is_null(TSNode self)
     * }
     */
    public static MemorySegment ts_node_is_null$address() {
        return ts_node_is_null.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_node_is_null(TSNode self)
     * }
     */
    public static boolean ts_node_is_null(MemorySegment self) {
        var mh$ = ts_node_is_null.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_is_null", self);
            }
            return (boolean)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_is_named {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_is_named");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_node_is_named(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_is_named$descriptor() {
        return ts_node_is_named.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_node_is_named(TSNode self)
     * }
     */
    public static MethodHandle ts_node_is_named$handle() {
        return ts_node_is_named.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_node_is_named(TSNode self)
     * }
     */
    public static MemorySegment ts_node_is_named$address() {
        return ts_node_is_named.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_node_is_named(TSNode self)
     * }
     */
    public static boolean ts_node_is_named(MemorySegment self) {
        var mh$ = ts_node_is_named.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_is_named", self);
            }
            return (boolean)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_is_missing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_is_missing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_node_is_missing(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_is_missing$descriptor() {
        return ts_node_is_missing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_node_is_missing(TSNode self)
     * }
     */
    public static MethodHandle ts_node_is_missing$handle() {
        return ts_node_is_missing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_node_is_missing(TSNode self)
     * }
     */
    public static MemorySegment ts_node_is_missing$address() {
        return ts_node_is_missing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_node_is_missing(TSNode self)
     * }
     */
    public static boolean ts_node_is_missing(MemorySegment self) {
        var mh$ = ts_node_is_missing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_is_missing", self);
            }
            return (boolean)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_is_extra {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_is_extra");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_node_is_extra(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_is_extra$descriptor() {
        return ts_node_is_extra.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_node_is_extra(TSNode self)
     * }
     */
    public static MethodHandle ts_node_is_extra$handle() {
        return ts_node_is_extra.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_node_is_extra(TSNode self)
     * }
     */
    public static MemorySegment ts_node_is_extra$address() {
        return ts_node_is_extra.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_node_is_extra(TSNode self)
     * }
     */
    public static boolean ts_node_is_extra(MemorySegment self) {
        var mh$ = ts_node_is_extra.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_is_extra", self);
            }
            return (boolean)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_has_changes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_has_changes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_node_has_changes(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_has_changes$descriptor() {
        return ts_node_has_changes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_node_has_changes(TSNode self)
     * }
     */
    public static MethodHandle ts_node_has_changes$handle() {
        return ts_node_has_changes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_node_has_changes(TSNode self)
     * }
     */
    public static MemorySegment ts_node_has_changes$address() {
        return ts_node_has_changes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_node_has_changes(TSNode self)
     * }
     */
    public static boolean ts_node_has_changes(MemorySegment self) {
        var mh$ = ts_node_has_changes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_has_changes", self);
            }
            return (boolean)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_has_error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_has_error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_node_has_error(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_has_error$descriptor() {
        return ts_node_has_error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_node_has_error(TSNode self)
     * }
     */
    public static MethodHandle ts_node_has_error$handle() {
        return ts_node_has_error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_node_has_error(TSNode self)
     * }
     */
    public static MemorySegment ts_node_has_error$address() {
        return ts_node_has_error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_node_has_error(TSNode self)
     * }
     */
    public static boolean ts_node_has_error(MemorySegment self) {
        var mh$ = ts_node_has_error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_has_error", self);
            }
            return (boolean)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_is_error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_is_error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_node_is_error(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_is_error$descriptor() {
        return ts_node_is_error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_node_is_error(TSNode self)
     * }
     */
    public static MethodHandle ts_node_is_error$handle() {
        return ts_node_is_error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_node_is_error(TSNode self)
     * }
     */
    public static MemorySegment ts_node_is_error$address() {
        return ts_node_is_error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_node_is_error(TSNode self)
     * }
     */
    public static boolean ts_node_is_error(MemorySegment self) {
        var mh$ = ts_node_is_error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_is_error", self);
            }
            return (boolean)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_parse_state {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_SHORT,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_parse_state");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSStateId ts_node_parse_state(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_parse_state$descriptor() {
        return ts_node_parse_state.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSStateId ts_node_parse_state(TSNode self)
     * }
     */
    public static MethodHandle ts_node_parse_state$handle() {
        return ts_node_parse_state.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSStateId ts_node_parse_state(TSNode self)
     * }
     */
    public static MemorySegment ts_node_parse_state$address() {
        return ts_node_parse_state.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSStateId ts_node_parse_state(TSNode self)
     * }
     */
    public static short ts_node_parse_state(MemorySegment self) {
        var mh$ = ts_node_parse_state.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_parse_state", self);
            }
            return (short)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_next_parse_state {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_SHORT,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_next_parse_state");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSStateId ts_node_next_parse_state(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_next_parse_state$descriptor() {
        return ts_node_next_parse_state.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSStateId ts_node_next_parse_state(TSNode self)
     * }
     */
    public static MethodHandle ts_node_next_parse_state$handle() {
        return ts_node_next_parse_state.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSStateId ts_node_next_parse_state(TSNode self)
     * }
     */
    public static MemorySegment ts_node_next_parse_state$address() {
        return ts_node_next_parse_state.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSStateId ts_node_next_parse_state(TSNode self)
     * }
     */
    public static short ts_node_next_parse_state(MemorySegment self) {
        var mh$ = ts_node_next_parse_state.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_next_parse_state", self);
            }
            return (short)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_parent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_parent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_parent(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_parent$descriptor() {
        return ts_node_parent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_parent(TSNode self)
     * }
     */
    public static MethodHandle ts_node_parent$handle() {
        return ts_node_parent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_parent(TSNode self)
     * }
     */
    public static MemorySegment ts_node_parent$address() {
        return ts_node_parent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_parent(TSNode self)
     * }
     */
    public static MemorySegment ts_node_parent(SegmentAllocator allocator, MemorySegment self) {
        var mh$ = ts_node_parent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_parent", allocator, self);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_child_containing_descendant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout(),
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_child_containing_descendant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_child_containing_descendant(TSNode self, TSNode descendant)
     * }
     */
    public static FunctionDescriptor ts_node_child_containing_descendant$descriptor() {
        return ts_node_child_containing_descendant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_child_containing_descendant(TSNode self, TSNode descendant)
     * }
     */
    public static MethodHandle ts_node_child_containing_descendant$handle() {
        return ts_node_child_containing_descendant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_child_containing_descendant(TSNode self, TSNode descendant)
     * }
     */
    public static MemorySegment ts_node_child_containing_descendant$address() {
        return ts_node_child_containing_descendant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_child_containing_descendant(TSNode self, TSNode descendant)
     * }
     */
    public static MemorySegment ts_node_child_containing_descendant(SegmentAllocator allocator, MemorySegment self, MemorySegment descendant) {
        var mh$ = ts_node_child_containing_descendant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_child_containing_descendant", allocator, self, descendant);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self, descendant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_child {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout(),
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_child");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_child(TSNode self, uint32_t child_index)
     * }
     */
    public static FunctionDescriptor ts_node_child$descriptor() {
        return ts_node_child.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_child(TSNode self, uint32_t child_index)
     * }
     */
    public static MethodHandle ts_node_child$handle() {
        return ts_node_child.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_child(TSNode self, uint32_t child_index)
     * }
     */
    public static MemorySegment ts_node_child$address() {
        return ts_node_child.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_child(TSNode self, uint32_t child_index)
     * }
     */
    public static MemorySegment ts_node_child(SegmentAllocator allocator, MemorySegment self, int child_index) {
        var mh$ = ts_node_child.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_child", allocator, self, child_index);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self, child_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_field_name_for_child {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TSNode.layout(),
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_field_name_for_child");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ts_node_field_name_for_child(TSNode self, uint32_t child_index)
     * }
     */
    public static FunctionDescriptor ts_node_field_name_for_child$descriptor() {
        return ts_node_field_name_for_child.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ts_node_field_name_for_child(TSNode self, uint32_t child_index)
     * }
     */
    public static MethodHandle ts_node_field_name_for_child$handle() {
        return ts_node_field_name_for_child.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ts_node_field_name_for_child(TSNode self, uint32_t child_index)
     * }
     */
    public static MemorySegment ts_node_field_name_for_child$address() {
        return ts_node_field_name_for_child.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ts_node_field_name_for_child(TSNode self, uint32_t child_index)
     * }
     */
    public static MemorySegment ts_node_field_name_for_child(MemorySegment self, int child_index) {
        var mh$ = ts_node_field_name_for_child.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_field_name_for_child", self, child_index);
            }
            return (MemorySegment)mh$.invokeExact(self, child_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_child_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_child_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_node_child_count(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_child_count$descriptor() {
        return ts_node_child_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_node_child_count(TSNode self)
     * }
     */
    public static MethodHandle ts_node_child_count$handle() {
        return ts_node_child_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_node_child_count(TSNode self)
     * }
     */
    public static MemorySegment ts_node_child_count$address() {
        return ts_node_child_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_node_child_count(TSNode self)
     * }
     */
    public static int ts_node_child_count(MemorySegment self) {
        var mh$ = ts_node_child_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_child_count", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_named_child {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout(),
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_named_child");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_named_child(TSNode self, uint32_t child_index)
     * }
     */
    public static FunctionDescriptor ts_node_named_child$descriptor() {
        return ts_node_named_child.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_named_child(TSNode self, uint32_t child_index)
     * }
     */
    public static MethodHandle ts_node_named_child$handle() {
        return ts_node_named_child.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_named_child(TSNode self, uint32_t child_index)
     * }
     */
    public static MemorySegment ts_node_named_child$address() {
        return ts_node_named_child.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_named_child(TSNode self, uint32_t child_index)
     * }
     */
    public static MemorySegment ts_node_named_child(SegmentAllocator allocator, MemorySegment self, int child_index) {
        var mh$ = ts_node_named_child.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_named_child", allocator, self, child_index);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self, child_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_named_child_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_named_child_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_node_named_child_count(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_named_child_count$descriptor() {
        return ts_node_named_child_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_node_named_child_count(TSNode self)
     * }
     */
    public static MethodHandle ts_node_named_child_count$handle() {
        return ts_node_named_child_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_node_named_child_count(TSNode self)
     * }
     */
    public static MemorySegment ts_node_named_child_count$address() {
        return ts_node_named_child_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_node_named_child_count(TSNode self)
     * }
     */
    public static int ts_node_named_child_count(MemorySegment self) {
        var mh$ = ts_node_named_child_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_named_child_count", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_child_by_field_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout(),
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_child_by_field_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_child_by_field_name(TSNode self, const char *name, uint32_t name_length)
     * }
     */
    public static FunctionDescriptor ts_node_child_by_field_name$descriptor() {
        return ts_node_child_by_field_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_child_by_field_name(TSNode self, const char *name, uint32_t name_length)
     * }
     */
    public static MethodHandle ts_node_child_by_field_name$handle() {
        return ts_node_child_by_field_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_child_by_field_name(TSNode self, const char *name, uint32_t name_length)
     * }
     */
    public static MemorySegment ts_node_child_by_field_name$address() {
        return ts_node_child_by_field_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_child_by_field_name(TSNode self, const char *name, uint32_t name_length)
     * }
     */
    public static MemorySegment ts_node_child_by_field_name(SegmentAllocator allocator, MemorySegment self, MemorySegment name, int name_length) {
        var mh$ = ts_node_child_by_field_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_child_by_field_name", allocator, self, name, name_length);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self, name, name_length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_child_by_field_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout(),
            TreeSitter.C_SHORT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_child_by_field_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_child_by_field_id(TSNode self, TSFieldId field_id)
     * }
     */
    public static FunctionDescriptor ts_node_child_by_field_id$descriptor() {
        return ts_node_child_by_field_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_child_by_field_id(TSNode self, TSFieldId field_id)
     * }
     */
    public static MethodHandle ts_node_child_by_field_id$handle() {
        return ts_node_child_by_field_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_child_by_field_id(TSNode self, TSFieldId field_id)
     * }
     */
    public static MemorySegment ts_node_child_by_field_id$address() {
        return ts_node_child_by_field_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_child_by_field_id(TSNode self, TSFieldId field_id)
     * }
     */
    public static MemorySegment ts_node_child_by_field_id(SegmentAllocator allocator, MemorySegment self, short field_id) {
        var mh$ = ts_node_child_by_field_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_child_by_field_id", allocator, self, field_id);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self, field_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_next_sibling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_next_sibling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_next_sibling(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_next_sibling$descriptor() {
        return ts_node_next_sibling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_next_sibling(TSNode self)
     * }
     */
    public static MethodHandle ts_node_next_sibling$handle() {
        return ts_node_next_sibling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_next_sibling(TSNode self)
     * }
     */
    public static MemorySegment ts_node_next_sibling$address() {
        return ts_node_next_sibling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_next_sibling(TSNode self)
     * }
     */
    public static MemorySegment ts_node_next_sibling(SegmentAllocator allocator, MemorySegment self) {
        var mh$ = ts_node_next_sibling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_next_sibling", allocator, self);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_prev_sibling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_prev_sibling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_prev_sibling(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_prev_sibling$descriptor() {
        return ts_node_prev_sibling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_prev_sibling(TSNode self)
     * }
     */
    public static MethodHandle ts_node_prev_sibling$handle() {
        return ts_node_prev_sibling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_prev_sibling(TSNode self)
     * }
     */
    public static MemorySegment ts_node_prev_sibling$address() {
        return ts_node_prev_sibling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_prev_sibling(TSNode self)
     * }
     */
    public static MemorySegment ts_node_prev_sibling(SegmentAllocator allocator, MemorySegment self) {
        var mh$ = ts_node_prev_sibling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_prev_sibling", allocator, self);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_next_named_sibling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_next_named_sibling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_next_named_sibling(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_next_named_sibling$descriptor() {
        return ts_node_next_named_sibling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_next_named_sibling(TSNode self)
     * }
     */
    public static MethodHandle ts_node_next_named_sibling$handle() {
        return ts_node_next_named_sibling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_next_named_sibling(TSNode self)
     * }
     */
    public static MemorySegment ts_node_next_named_sibling$address() {
        return ts_node_next_named_sibling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_next_named_sibling(TSNode self)
     * }
     */
    public static MemorySegment ts_node_next_named_sibling(SegmentAllocator allocator, MemorySegment self) {
        var mh$ = ts_node_next_named_sibling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_next_named_sibling", allocator, self);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_prev_named_sibling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_prev_named_sibling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_prev_named_sibling(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_prev_named_sibling$descriptor() {
        return ts_node_prev_named_sibling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_prev_named_sibling(TSNode self)
     * }
     */
    public static MethodHandle ts_node_prev_named_sibling$handle() {
        return ts_node_prev_named_sibling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_prev_named_sibling(TSNode self)
     * }
     */
    public static MemorySegment ts_node_prev_named_sibling$address() {
        return ts_node_prev_named_sibling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_prev_named_sibling(TSNode self)
     * }
     */
    public static MemorySegment ts_node_prev_named_sibling(SegmentAllocator allocator, MemorySegment self) {
        var mh$ = ts_node_prev_named_sibling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_prev_named_sibling", allocator, self);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_first_child_for_byte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout(),
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_first_child_for_byte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_first_child_for_byte(TSNode self, uint32_t byte)
     * }
     */
    public static FunctionDescriptor ts_node_first_child_for_byte$descriptor() {
        return ts_node_first_child_for_byte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_first_child_for_byte(TSNode self, uint32_t byte)
     * }
     */
    public static MethodHandle ts_node_first_child_for_byte$handle() {
        return ts_node_first_child_for_byte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_first_child_for_byte(TSNode self, uint32_t byte)
     * }
     */
    public static MemorySegment ts_node_first_child_for_byte$address() {
        return ts_node_first_child_for_byte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_first_child_for_byte(TSNode self, uint32_t byte)
     * }
     */
    public static MemorySegment ts_node_first_child_for_byte(SegmentAllocator allocator, MemorySegment self, int byte_) {
        var mh$ = ts_node_first_child_for_byte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_first_child_for_byte", allocator, self, byte_);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self, byte_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_first_named_child_for_byte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout(),
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_first_named_child_for_byte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_first_named_child_for_byte(TSNode self, uint32_t byte)
     * }
     */
    public static FunctionDescriptor ts_node_first_named_child_for_byte$descriptor() {
        return ts_node_first_named_child_for_byte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_first_named_child_for_byte(TSNode self, uint32_t byte)
     * }
     */
    public static MethodHandle ts_node_first_named_child_for_byte$handle() {
        return ts_node_first_named_child_for_byte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_first_named_child_for_byte(TSNode self, uint32_t byte)
     * }
     */
    public static MemorySegment ts_node_first_named_child_for_byte$address() {
        return ts_node_first_named_child_for_byte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_first_named_child_for_byte(TSNode self, uint32_t byte)
     * }
     */
    public static MemorySegment ts_node_first_named_child_for_byte(SegmentAllocator allocator, MemorySegment self, int byte_) {
        var mh$ = ts_node_first_named_child_for_byte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_first_named_child_for_byte", allocator, self, byte_);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self, byte_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_descendant_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_descendant_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_node_descendant_count(TSNode self)
     * }
     */
    public static FunctionDescriptor ts_node_descendant_count$descriptor() {
        return ts_node_descendant_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_node_descendant_count(TSNode self)
     * }
     */
    public static MethodHandle ts_node_descendant_count$handle() {
        return ts_node_descendant_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_node_descendant_count(TSNode self)
     * }
     */
    public static MemorySegment ts_node_descendant_count$address() {
        return ts_node_descendant_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_node_descendant_count(TSNode self)
     * }
     */
    public static int ts_node_descendant_count(MemorySegment self) {
        var mh$ = ts_node_descendant_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_descendant_count", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_descendant_for_byte_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout(),
            TreeSitter.C_INT,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_descendant_for_byte_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_descendant_for_byte_range(TSNode self, uint32_t start, uint32_t end)
     * }
     */
    public static FunctionDescriptor ts_node_descendant_for_byte_range$descriptor() {
        return ts_node_descendant_for_byte_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_descendant_for_byte_range(TSNode self, uint32_t start, uint32_t end)
     * }
     */
    public static MethodHandle ts_node_descendant_for_byte_range$handle() {
        return ts_node_descendant_for_byte_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_descendant_for_byte_range(TSNode self, uint32_t start, uint32_t end)
     * }
     */
    public static MemorySegment ts_node_descendant_for_byte_range$address() {
        return ts_node_descendant_for_byte_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_descendant_for_byte_range(TSNode self, uint32_t start, uint32_t end)
     * }
     */
    public static MemorySegment ts_node_descendant_for_byte_range(SegmentAllocator allocator, MemorySegment self, int start, int end) {
        var mh$ = ts_node_descendant_for_byte_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_descendant_for_byte_range", allocator, self, start, end);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_descendant_for_point_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout(),
            TSPoint.layout(),
            TSPoint.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_descendant_for_point_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_descendant_for_point_range(TSNode self, TSPoint start, TSPoint end)
     * }
     */
    public static FunctionDescriptor ts_node_descendant_for_point_range$descriptor() {
        return ts_node_descendant_for_point_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_descendant_for_point_range(TSNode self, TSPoint start, TSPoint end)
     * }
     */
    public static MethodHandle ts_node_descendant_for_point_range$handle() {
        return ts_node_descendant_for_point_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_descendant_for_point_range(TSNode self, TSPoint start, TSPoint end)
     * }
     */
    public static MemorySegment ts_node_descendant_for_point_range$address() {
        return ts_node_descendant_for_point_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_descendant_for_point_range(TSNode self, TSPoint start, TSPoint end)
     * }
     */
    public static MemorySegment ts_node_descendant_for_point_range(SegmentAllocator allocator, MemorySegment self, MemorySegment start, MemorySegment end) {
        var mh$ = ts_node_descendant_for_point_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_descendant_for_point_range", allocator, self, start, end);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_named_descendant_for_byte_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout(),
            TreeSitter.C_INT,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_named_descendant_for_byte_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_named_descendant_for_byte_range(TSNode self, uint32_t start, uint32_t end)
     * }
     */
    public static FunctionDescriptor ts_node_named_descendant_for_byte_range$descriptor() {
        return ts_node_named_descendant_for_byte_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_named_descendant_for_byte_range(TSNode self, uint32_t start, uint32_t end)
     * }
     */
    public static MethodHandle ts_node_named_descendant_for_byte_range$handle() {
        return ts_node_named_descendant_for_byte_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_named_descendant_for_byte_range(TSNode self, uint32_t start, uint32_t end)
     * }
     */
    public static MemorySegment ts_node_named_descendant_for_byte_range$address() {
        return ts_node_named_descendant_for_byte_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_named_descendant_for_byte_range(TSNode self, uint32_t start, uint32_t end)
     * }
     */
    public static MemorySegment ts_node_named_descendant_for_byte_range(SegmentAllocator allocator, MemorySegment self, int start, int end) {
        var mh$ = ts_node_named_descendant_for_byte_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_named_descendant_for_byte_range", allocator, self, start, end);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_named_descendant_for_point_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TSNode.layout(),
            TSPoint.layout(),
            TSPoint.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_named_descendant_for_point_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_node_named_descendant_for_point_range(TSNode self, TSPoint start, TSPoint end)
     * }
     */
    public static FunctionDescriptor ts_node_named_descendant_for_point_range$descriptor() {
        return ts_node_named_descendant_for_point_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_node_named_descendant_for_point_range(TSNode self, TSPoint start, TSPoint end)
     * }
     */
    public static MethodHandle ts_node_named_descendant_for_point_range$handle() {
        return ts_node_named_descendant_for_point_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_node_named_descendant_for_point_range(TSNode self, TSPoint start, TSPoint end)
     * }
     */
    public static MemorySegment ts_node_named_descendant_for_point_range$address() {
        return ts_node_named_descendant_for_point_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_node_named_descendant_for_point_range(TSNode self, TSPoint start, TSPoint end)
     * }
     */
    public static MemorySegment ts_node_named_descendant_for_point_range(SegmentAllocator allocator, MemorySegment self, MemorySegment start, MemorySegment end) {
        var mh$ = ts_node_named_descendant_for_point_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_named_descendant_for_point_range", allocator, self, start, end);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self, start, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_edit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_edit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_node_edit(TSNode *self, const TSInputEdit *edit)
     * }
     */
    public static FunctionDescriptor ts_node_edit$descriptor() {
        return ts_node_edit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_node_edit(TSNode *self, const TSInputEdit *edit)
     * }
     */
    public static MethodHandle ts_node_edit$handle() {
        return ts_node_edit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_node_edit(TSNode *self, const TSInputEdit *edit)
     * }
     */
    public static MemorySegment ts_node_edit$address() {
        return ts_node_edit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_node_edit(TSNode *self, const TSInputEdit *edit)
     * }
     */
    public static void ts_node_edit(MemorySegment self, MemorySegment edit) {
        var mh$ = ts_node_edit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_edit", self, edit);
            }
            mh$.invokeExact(self, edit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_node_eq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TSNode.layout(),
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_node_eq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_node_eq(TSNode self, TSNode other)
     * }
     */
    public static FunctionDescriptor ts_node_eq$descriptor() {
        return ts_node_eq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_node_eq(TSNode self, TSNode other)
     * }
     */
    public static MethodHandle ts_node_eq$handle() {
        return ts_node_eq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_node_eq(TSNode self, TSNode other)
     * }
     */
    public static MemorySegment ts_node_eq$address() {
        return ts_node_eq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_node_eq(TSNode self, TSNode other)
     * }
     */
    public static boolean ts_node_eq(MemorySegment self, MemorySegment other) {
        var mh$ = ts_node_eq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_node_eq", self, other);
            }
            return (boolean)mh$.invokeExact(self, other);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSTreeCursor.layout(),
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSTreeCursor ts_tree_cursor_new(TSNode node)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_new$descriptor() {
        return ts_tree_cursor_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSTreeCursor ts_tree_cursor_new(TSNode node)
     * }
     */
    public static MethodHandle ts_tree_cursor_new$handle() {
        return ts_tree_cursor_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSTreeCursor ts_tree_cursor_new(TSNode node)
     * }
     */
    public static MemorySegment ts_tree_cursor_new$address() {
        return ts_tree_cursor_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSTreeCursor ts_tree_cursor_new(TSNode node)
     * }
     */
    public static MemorySegment ts_tree_cursor_new(SegmentAllocator allocator, MemorySegment node) {
        var mh$ = ts_tree_cursor_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_new", allocator, node);
            }
            return (MemorySegment)mh$.invokeExact(allocator, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_tree_cursor_delete(TSTreeCursor *self)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_delete$descriptor() {
        return ts_tree_cursor_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_tree_cursor_delete(TSTreeCursor *self)
     * }
     */
    public static MethodHandle ts_tree_cursor_delete$handle() {
        return ts_tree_cursor_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_tree_cursor_delete(TSTreeCursor *self)
     * }
     */
    public static MemorySegment ts_tree_cursor_delete$address() {
        return ts_tree_cursor_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_tree_cursor_delete(TSTreeCursor *self)
     * }
     */
    public static void ts_tree_cursor_delete(MemorySegment self) {
        var mh$ = ts_tree_cursor_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_delete", self);
            }
            mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_tree_cursor_reset(TSTreeCursor *self, TSNode node)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_reset$descriptor() {
        return ts_tree_cursor_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_tree_cursor_reset(TSTreeCursor *self, TSNode node)
     * }
     */
    public static MethodHandle ts_tree_cursor_reset$handle() {
        return ts_tree_cursor_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_tree_cursor_reset(TSTreeCursor *self, TSNode node)
     * }
     */
    public static MemorySegment ts_tree_cursor_reset$address() {
        return ts_tree_cursor_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_tree_cursor_reset(TSTreeCursor *self, TSNode node)
     * }
     */
    public static void ts_tree_cursor_reset(MemorySegment self, MemorySegment node) {
        var mh$ = ts_tree_cursor_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_reset", self, node);
            }
            mh$.invokeExact(self, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_reset_to {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_reset_to");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_tree_cursor_reset_to(TSTreeCursor *dst, const TSTreeCursor *src)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_reset_to$descriptor() {
        return ts_tree_cursor_reset_to.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_tree_cursor_reset_to(TSTreeCursor *dst, const TSTreeCursor *src)
     * }
     */
    public static MethodHandle ts_tree_cursor_reset_to$handle() {
        return ts_tree_cursor_reset_to.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_tree_cursor_reset_to(TSTreeCursor *dst, const TSTreeCursor *src)
     * }
     */
    public static MemorySegment ts_tree_cursor_reset_to$address() {
        return ts_tree_cursor_reset_to.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_tree_cursor_reset_to(TSTreeCursor *dst, const TSTreeCursor *src)
     * }
     */
    public static void ts_tree_cursor_reset_to(MemorySegment dst, MemorySegment src) {
        var mh$ = ts_tree_cursor_reset_to.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_reset_to", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_current_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSNode.layout(),
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_current_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSNode ts_tree_cursor_current_node(const TSTreeCursor *self)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_current_node$descriptor() {
        return ts_tree_cursor_current_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSNode ts_tree_cursor_current_node(const TSTreeCursor *self)
     * }
     */
    public static MethodHandle ts_tree_cursor_current_node$handle() {
        return ts_tree_cursor_current_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSNode ts_tree_cursor_current_node(const TSTreeCursor *self)
     * }
     */
    public static MemorySegment ts_tree_cursor_current_node$address() {
        return ts_tree_cursor_current_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSNode ts_tree_cursor_current_node(const TSTreeCursor *self)
     * }
     */
    public static MemorySegment ts_tree_cursor_current_node(SegmentAllocator allocator, MemorySegment self) {
        var mh$ = ts_tree_cursor_current_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_current_node", allocator, self);
            }
            return (MemorySegment)mh$.invokeExact(allocator, self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_current_field_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_current_field_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ts_tree_cursor_current_field_name(const TSTreeCursor *self)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_current_field_name$descriptor() {
        return ts_tree_cursor_current_field_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ts_tree_cursor_current_field_name(const TSTreeCursor *self)
     * }
     */
    public static MethodHandle ts_tree_cursor_current_field_name$handle() {
        return ts_tree_cursor_current_field_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ts_tree_cursor_current_field_name(const TSTreeCursor *self)
     * }
     */
    public static MemorySegment ts_tree_cursor_current_field_name$address() {
        return ts_tree_cursor_current_field_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ts_tree_cursor_current_field_name(const TSTreeCursor *self)
     * }
     */
    public static MemorySegment ts_tree_cursor_current_field_name(MemorySegment self) {
        var mh$ = ts_tree_cursor_current_field_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_current_field_name", self);
            }
            return (MemorySegment)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_current_field_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_SHORT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_current_field_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSFieldId ts_tree_cursor_current_field_id(const TSTreeCursor *self)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_current_field_id$descriptor() {
        return ts_tree_cursor_current_field_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSFieldId ts_tree_cursor_current_field_id(const TSTreeCursor *self)
     * }
     */
    public static MethodHandle ts_tree_cursor_current_field_id$handle() {
        return ts_tree_cursor_current_field_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSFieldId ts_tree_cursor_current_field_id(const TSTreeCursor *self)
     * }
     */
    public static MemorySegment ts_tree_cursor_current_field_id$address() {
        return ts_tree_cursor_current_field_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSFieldId ts_tree_cursor_current_field_id(const TSTreeCursor *self)
     * }
     */
    public static short ts_tree_cursor_current_field_id(MemorySegment self) {
        var mh$ = ts_tree_cursor_current_field_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_current_field_id", self);
            }
            return (short)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_goto_parent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_goto_parent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_parent(TSTreeCursor *self)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_goto_parent$descriptor() {
        return ts_tree_cursor_goto_parent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_parent(TSTreeCursor *self)
     * }
     */
    public static MethodHandle ts_tree_cursor_goto_parent$handle() {
        return ts_tree_cursor_goto_parent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_parent(TSTreeCursor *self)
     * }
     */
    public static MemorySegment ts_tree_cursor_goto_parent$address() {
        return ts_tree_cursor_goto_parent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_parent(TSTreeCursor *self)
     * }
     */
    public static boolean ts_tree_cursor_goto_parent(MemorySegment self) {
        var mh$ = ts_tree_cursor_goto_parent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_goto_parent", self);
            }
            return (boolean)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_goto_next_sibling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_goto_next_sibling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_next_sibling(TSTreeCursor *self)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_goto_next_sibling$descriptor() {
        return ts_tree_cursor_goto_next_sibling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_next_sibling(TSTreeCursor *self)
     * }
     */
    public static MethodHandle ts_tree_cursor_goto_next_sibling$handle() {
        return ts_tree_cursor_goto_next_sibling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_next_sibling(TSTreeCursor *self)
     * }
     */
    public static MemorySegment ts_tree_cursor_goto_next_sibling$address() {
        return ts_tree_cursor_goto_next_sibling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_next_sibling(TSTreeCursor *self)
     * }
     */
    public static boolean ts_tree_cursor_goto_next_sibling(MemorySegment self) {
        var mh$ = ts_tree_cursor_goto_next_sibling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_goto_next_sibling", self);
            }
            return (boolean)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_goto_previous_sibling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_goto_previous_sibling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_previous_sibling(TSTreeCursor *self)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_goto_previous_sibling$descriptor() {
        return ts_tree_cursor_goto_previous_sibling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_previous_sibling(TSTreeCursor *self)
     * }
     */
    public static MethodHandle ts_tree_cursor_goto_previous_sibling$handle() {
        return ts_tree_cursor_goto_previous_sibling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_previous_sibling(TSTreeCursor *self)
     * }
     */
    public static MemorySegment ts_tree_cursor_goto_previous_sibling$address() {
        return ts_tree_cursor_goto_previous_sibling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_previous_sibling(TSTreeCursor *self)
     * }
     */
    public static boolean ts_tree_cursor_goto_previous_sibling(MemorySegment self) {
        var mh$ = ts_tree_cursor_goto_previous_sibling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_goto_previous_sibling", self);
            }
            return (boolean)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_goto_first_child {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_goto_first_child");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_first_child(TSTreeCursor *self)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_goto_first_child$descriptor() {
        return ts_tree_cursor_goto_first_child.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_first_child(TSTreeCursor *self)
     * }
     */
    public static MethodHandle ts_tree_cursor_goto_first_child$handle() {
        return ts_tree_cursor_goto_first_child.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_first_child(TSTreeCursor *self)
     * }
     */
    public static MemorySegment ts_tree_cursor_goto_first_child$address() {
        return ts_tree_cursor_goto_first_child.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_first_child(TSTreeCursor *self)
     * }
     */
    public static boolean ts_tree_cursor_goto_first_child(MemorySegment self) {
        var mh$ = ts_tree_cursor_goto_first_child.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_goto_first_child", self);
            }
            return (boolean)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_goto_last_child {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_goto_last_child");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_last_child(TSTreeCursor *self)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_goto_last_child$descriptor() {
        return ts_tree_cursor_goto_last_child.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_last_child(TSTreeCursor *self)
     * }
     */
    public static MethodHandle ts_tree_cursor_goto_last_child$handle() {
        return ts_tree_cursor_goto_last_child.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_last_child(TSTreeCursor *self)
     * }
     */
    public static MemorySegment ts_tree_cursor_goto_last_child$address() {
        return ts_tree_cursor_goto_last_child.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_tree_cursor_goto_last_child(TSTreeCursor *self)
     * }
     */
    public static boolean ts_tree_cursor_goto_last_child(MemorySegment self) {
        var mh$ = ts_tree_cursor_goto_last_child.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_goto_last_child", self);
            }
            return (boolean)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_goto_descendant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_goto_descendant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_tree_cursor_goto_descendant(TSTreeCursor *self, uint32_t goal_descendant_index)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_goto_descendant$descriptor() {
        return ts_tree_cursor_goto_descendant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_tree_cursor_goto_descendant(TSTreeCursor *self, uint32_t goal_descendant_index)
     * }
     */
    public static MethodHandle ts_tree_cursor_goto_descendant$handle() {
        return ts_tree_cursor_goto_descendant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_tree_cursor_goto_descendant(TSTreeCursor *self, uint32_t goal_descendant_index)
     * }
     */
    public static MemorySegment ts_tree_cursor_goto_descendant$address() {
        return ts_tree_cursor_goto_descendant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_tree_cursor_goto_descendant(TSTreeCursor *self, uint32_t goal_descendant_index)
     * }
     */
    public static void ts_tree_cursor_goto_descendant(MemorySegment self, int goal_descendant_index) {
        var mh$ = ts_tree_cursor_goto_descendant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_goto_descendant", self, goal_descendant_index);
            }
            mh$.invokeExact(self, goal_descendant_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_current_descendant_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_current_descendant_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_tree_cursor_current_descendant_index(const TSTreeCursor *self)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_current_descendant_index$descriptor() {
        return ts_tree_cursor_current_descendant_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_tree_cursor_current_descendant_index(const TSTreeCursor *self)
     * }
     */
    public static MethodHandle ts_tree_cursor_current_descendant_index$handle() {
        return ts_tree_cursor_current_descendant_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_tree_cursor_current_descendant_index(const TSTreeCursor *self)
     * }
     */
    public static MemorySegment ts_tree_cursor_current_descendant_index$address() {
        return ts_tree_cursor_current_descendant_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_tree_cursor_current_descendant_index(const TSTreeCursor *self)
     * }
     */
    public static int ts_tree_cursor_current_descendant_index(MemorySegment self) {
        var mh$ = ts_tree_cursor_current_descendant_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_current_descendant_index", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_current_depth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_current_depth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_tree_cursor_current_depth(const TSTreeCursor *self)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_current_depth$descriptor() {
        return ts_tree_cursor_current_depth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_tree_cursor_current_depth(const TSTreeCursor *self)
     * }
     */
    public static MethodHandle ts_tree_cursor_current_depth$handle() {
        return ts_tree_cursor_current_depth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_tree_cursor_current_depth(const TSTreeCursor *self)
     * }
     */
    public static MemorySegment ts_tree_cursor_current_depth$address() {
        return ts_tree_cursor_current_depth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_tree_cursor_current_depth(const TSTreeCursor *self)
     * }
     */
    public static int ts_tree_cursor_current_depth(MemorySegment self) {
        var mh$ = ts_tree_cursor_current_depth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_current_depth", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_goto_first_child_for_byte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_LONG,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_goto_first_child_for_byte");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t ts_tree_cursor_goto_first_child_for_byte(TSTreeCursor *self, uint32_t goal_byte)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_goto_first_child_for_byte$descriptor() {
        return ts_tree_cursor_goto_first_child_for_byte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t ts_tree_cursor_goto_first_child_for_byte(TSTreeCursor *self, uint32_t goal_byte)
     * }
     */
    public static MethodHandle ts_tree_cursor_goto_first_child_for_byte$handle() {
        return ts_tree_cursor_goto_first_child_for_byte.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t ts_tree_cursor_goto_first_child_for_byte(TSTreeCursor *self, uint32_t goal_byte)
     * }
     */
    public static MemorySegment ts_tree_cursor_goto_first_child_for_byte$address() {
        return ts_tree_cursor_goto_first_child_for_byte.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t ts_tree_cursor_goto_first_child_for_byte(TSTreeCursor *self, uint32_t goal_byte)
     * }
     */
    public static long ts_tree_cursor_goto_first_child_for_byte(MemorySegment self, int goal_byte) {
        var mh$ = ts_tree_cursor_goto_first_child_for_byte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_goto_first_child_for_byte", self, goal_byte);
            }
            return (long)mh$.invokeExact(self, goal_byte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_goto_first_child_for_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_LONG,
            TreeSitter.C_POINTER,
            TSPoint.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_goto_first_child_for_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t ts_tree_cursor_goto_first_child_for_point(TSTreeCursor *self, TSPoint goal_point)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_goto_first_child_for_point$descriptor() {
        return ts_tree_cursor_goto_first_child_for_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t ts_tree_cursor_goto_first_child_for_point(TSTreeCursor *self, TSPoint goal_point)
     * }
     */
    public static MethodHandle ts_tree_cursor_goto_first_child_for_point$handle() {
        return ts_tree_cursor_goto_first_child_for_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t ts_tree_cursor_goto_first_child_for_point(TSTreeCursor *self, TSPoint goal_point)
     * }
     */
    public static MemorySegment ts_tree_cursor_goto_first_child_for_point$address() {
        return ts_tree_cursor_goto_first_child_for_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t ts_tree_cursor_goto_first_child_for_point(TSTreeCursor *self, TSPoint goal_point)
     * }
     */
    public static long ts_tree_cursor_goto_first_child_for_point(MemorySegment self, MemorySegment goal_point) {
        var mh$ = ts_tree_cursor_goto_first_child_for_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_goto_first_child_for_point", self, goal_point);
            }
            return (long)mh$.invokeExact(self, goal_point);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_tree_cursor_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TSTreeCursor.layout(),
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_tree_cursor_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSTreeCursor ts_tree_cursor_copy(const TSTreeCursor *cursor)
     * }
     */
    public static FunctionDescriptor ts_tree_cursor_copy$descriptor() {
        return ts_tree_cursor_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSTreeCursor ts_tree_cursor_copy(const TSTreeCursor *cursor)
     * }
     */
    public static MethodHandle ts_tree_cursor_copy$handle() {
        return ts_tree_cursor_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSTreeCursor ts_tree_cursor_copy(const TSTreeCursor *cursor)
     * }
     */
    public static MemorySegment ts_tree_cursor_copy$address() {
        return ts_tree_cursor_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSTreeCursor ts_tree_cursor_copy(const TSTreeCursor *cursor)
     * }
     */
    public static MemorySegment ts_tree_cursor_copy(SegmentAllocator allocator, MemorySegment cursor) {
        var mh$ = ts_tree_cursor_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_tree_cursor_copy", allocator, cursor);
            }
            return (MemorySegment)mh$.invokeExact(allocator, cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSQuery *ts_query_new(const TSLanguage *language, const char *source, uint32_t source_len, uint32_t *error_offset, TSQueryError *error_type)
     * }
     */
    public static FunctionDescriptor ts_query_new$descriptor() {
        return ts_query_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSQuery *ts_query_new(const TSLanguage *language, const char *source, uint32_t source_len, uint32_t *error_offset, TSQueryError *error_type)
     * }
     */
    public static MethodHandle ts_query_new$handle() {
        return ts_query_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSQuery *ts_query_new(const TSLanguage *language, const char *source, uint32_t source_len, uint32_t *error_offset, TSQueryError *error_type)
     * }
     */
    public static MemorySegment ts_query_new$address() {
        return ts_query_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSQuery *ts_query_new(const TSLanguage *language, const char *source, uint32_t source_len, uint32_t *error_offset, TSQueryError *error_type)
     * }
     */
    public static MemorySegment ts_query_new(MemorySegment language, MemorySegment source, int source_len, MemorySegment error_offset, MemorySegment error_type) {
        var mh$ = ts_query_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_new", language, source, source_len, error_offset, error_type);
            }
            return (MemorySegment)mh$.invokeExact(language, source, source_len, error_offset, error_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_query_delete(TSQuery *self)
     * }
     */
    public static FunctionDescriptor ts_query_delete$descriptor() {
        return ts_query_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_query_delete(TSQuery *self)
     * }
     */
    public static MethodHandle ts_query_delete$handle() {
        return ts_query_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_query_delete(TSQuery *self)
     * }
     */
    public static MemorySegment ts_query_delete$address() {
        return ts_query_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_query_delete(TSQuery *self)
     * }
     */
    public static void ts_query_delete(MemorySegment self) {
        var mh$ = ts_query_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_delete", self);
            }
            mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_pattern_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_pattern_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_query_pattern_count(const TSQuery *self)
     * }
     */
    public static FunctionDescriptor ts_query_pattern_count$descriptor() {
        return ts_query_pattern_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_query_pattern_count(const TSQuery *self)
     * }
     */
    public static MethodHandle ts_query_pattern_count$handle() {
        return ts_query_pattern_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_query_pattern_count(const TSQuery *self)
     * }
     */
    public static MemorySegment ts_query_pattern_count$address() {
        return ts_query_pattern_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_query_pattern_count(const TSQuery *self)
     * }
     */
    public static int ts_query_pattern_count(MemorySegment self) {
        var mh$ = ts_query_pattern_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_pattern_count", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_capture_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_capture_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_query_capture_count(const TSQuery *self)
     * }
     */
    public static FunctionDescriptor ts_query_capture_count$descriptor() {
        return ts_query_capture_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_query_capture_count(const TSQuery *self)
     * }
     */
    public static MethodHandle ts_query_capture_count$handle() {
        return ts_query_capture_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_query_capture_count(const TSQuery *self)
     * }
     */
    public static MemorySegment ts_query_capture_count$address() {
        return ts_query_capture_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_query_capture_count(const TSQuery *self)
     * }
     */
    public static int ts_query_capture_count(MemorySegment self) {
        var mh$ = ts_query_capture_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_capture_count", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_string_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_string_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_query_string_count(const TSQuery *self)
     * }
     */
    public static FunctionDescriptor ts_query_string_count$descriptor() {
        return ts_query_string_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_query_string_count(const TSQuery *self)
     * }
     */
    public static MethodHandle ts_query_string_count$handle() {
        return ts_query_string_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_query_string_count(const TSQuery *self)
     * }
     */
    public static MemorySegment ts_query_string_count$address() {
        return ts_query_string_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_query_string_count(const TSQuery *self)
     * }
     */
    public static int ts_query_string_count(MemorySegment self) {
        var mh$ = ts_query_string_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_string_count", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_start_byte_for_pattern {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_start_byte_for_pattern");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_query_start_byte_for_pattern(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static FunctionDescriptor ts_query_start_byte_for_pattern$descriptor() {
        return ts_query_start_byte_for_pattern.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_query_start_byte_for_pattern(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static MethodHandle ts_query_start_byte_for_pattern$handle() {
        return ts_query_start_byte_for_pattern.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_query_start_byte_for_pattern(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static MemorySegment ts_query_start_byte_for_pattern$address() {
        return ts_query_start_byte_for_pattern.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_query_start_byte_for_pattern(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static int ts_query_start_byte_for_pattern(MemorySegment self, int pattern_index) {
        var mh$ = ts_query_start_byte_for_pattern.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_start_byte_for_pattern", self, pattern_index);
            }
            return (int)mh$.invokeExact(self, pattern_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_end_byte_for_pattern {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_end_byte_for_pattern");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_query_end_byte_for_pattern(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static FunctionDescriptor ts_query_end_byte_for_pattern$descriptor() {
        return ts_query_end_byte_for_pattern.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_query_end_byte_for_pattern(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static MethodHandle ts_query_end_byte_for_pattern$handle() {
        return ts_query_end_byte_for_pattern.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_query_end_byte_for_pattern(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static MemorySegment ts_query_end_byte_for_pattern$address() {
        return ts_query_end_byte_for_pattern.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_query_end_byte_for_pattern(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static int ts_query_end_byte_for_pattern(MemorySegment self, int pattern_index) {
        var mh$ = ts_query_end_byte_for_pattern.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_end_byte_for_pattern", self, pattern_index);
            }
            return (int)mh$.invokeExact(self, pattern_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_predicates_for_pattern {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_predicates_for_pattern");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const TSQueryPredicateStep *ts_query_predicates_for_pattern(const TSQuery *self, uint32_t pattern_index, uint32_t *step_count)
     * }
     */
    public static FunctionDescriptor ts_query_predicates_for_pattern$descriptor() {
        return ts_query_predicates_for_pattern.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const TSQueryPredicateStep *ts_query_predicates_for_pattern(const TSQuery *self, uint32_t pattern_index, uint32_t *step_count)
     * }
     */
    public static MethodHandle ts_query_predicates_for_pattern$handle() {
        return ts_query_predicates_for_pattern.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const TSQueryPredicateStep *ts_query_predicates_for_pattern(const TSQuery *self, uint32_t pattern_index, uint32_t *step_count)
     * }
     */
    public static MemorySegment ts_query_predicates_for_pattern$address() {
        return ts_query_predicates_for_pattern.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const TSQueryPredicateStep *ts_query_predicates_for_pattern(const TSQuery *self, uint32_t pattern_index, uint32_t *step_count)
     * }
     */
    public static MemorySegment ts_query_predicates_for_pattern(MemorySegment self, int pattern_index, MemorySegment step_count) {
        var mh$ = ts_query_predicates_for_pattern.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_predicates_for_pattern", self, pattern_index, step_count);
            }
            return (MemorySegment)mh$.invokeExact(self, pattern_index, step_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_is_pattern_rooted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_is_pattern_rooted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_query_is_pattern_rooted(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static FunctionDescriptor ts_query_is_pattern_rooted$descriptor() {
        return ts_query_is_pattern_rooted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_query_is_pattern_rooted(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static MethodHandle ts_query_is_pattern_rooted$handle() {
        return ts_query_is_pattern_rooted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_query_is_pattern_rooted(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static MemorySegment ts_query_is_pattern_rooted$address() {
        return ts_query_is_pattern_rooted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_query_is_pattern_rooted(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static boolean ts_query_is_pattern_rooted(MemorySegment self, int pattern_index) {
        var mh$ = ts_query_is_pattern_rooted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_is_pattern_rooted", self, pattern_index);
            }
            return (boolean)mh$.invokeExact(self, pattern_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_is_pattern_non_local {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_is_pattern_non_local");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_query_is_pattern_non_local(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static FunctionDescriptor ts_query_is_pattern_non_local$descriptor() {
        return ts_query_is_pattern_non_local.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_query_is_pattern_non_local(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static MethodHandle ts_query_is_pattern_non_local$handle() {
        return ts_query_is_pattern_non_local.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_query_is_pattern_non_local(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static MemorySegment ts_query_is_pattern_non_local$address() {
        return ts_query_is_pattern_non_local.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_query_is_pattern_non_local(const TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static boolean ts_query_is_pattern_non_local(MemorySegment self, int pattern_index) {
        var mh$ = ts_query_is_pattern_non_local.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_is_pattern_non_local", self, pattern_index);
            }
            return (boolean)mh$.invokeExact(self, pattern_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_is_pattern_guaranteed_at_step {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_is_pattern_guaranteed_at_step");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_query_is_pattern_guaranteed_at_step(const TSQuery *self, uint32_t byte_offset)
     * }
     */
    public static FunctionDescriptor ts_query_is_pattern_guaranteed_at_step$descriptor() {
        return ts_query_is_pattern_guaranteed_at_step.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_query_is_pattern_guaranteed_at_step(const TSQuery *self, uint32_t byte_offset)
     * }
     */
    public static MethodHandle ts_query_is_pattern_guaranteed_at_step$handle() {
        return ts_query_is_pattern_guaranteed_at_step.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_query_is_pattern_guaranteed_at_step(const TSQuery *self, uint32_t byte_offset)
     * }
     */
    public static MemorySegment ts_query_is_pattern_guaranteed_at_step$address() {
        return ts_query_is_pattern_guaranteed_at_step.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_query_is_pattern_guaranteed_at_step(const TSQuery *self, uint32_t byte_offset)
     * }
     */
    public static boolean ts_query_is_pattern_guaranteed_at_step(MemorySegment self, int byte_offset) {
        var mh$ = ts_query_is_pattern_guaranteed_at_step.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_is_pattern_guaranteed_at_step", self, byte_offset);
            }
            return (boolean)mh$.invokeExact(self, byte_offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_capture_name_for_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_capture_name_for_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ts_query_capture_name_for_id(const TSQuery *self, uint32_t index, uint32_t *length)
     * }
     */
    public static FunctionDescriptor ts_query_capture_name_for_id$descriptor() {
        return ts_query_capture_name_for_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ts_query_capture_name_for_id(const TSQuery *self, uint32_t index, uint32_t *length)
     * }
     */
    public static MethodHandle ts_query_capture_name_for_id$handle() {
        return ts_query_capture_name_for_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ts_query_capture_name_for_id(const TSQuery *self, uint32_t index, uint32_t *length)
     * }
     */
    public static MemorySegment ts_query_capture_name_for_id$address() {
        return ts_query_capture_name_for_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ts_query_capture_name_for_id(const TSQuery *self, uint32_t index, uint32_t *length)
     * }
     */
    public static MemorySegment ts_query_capture_name_for_id(MemorySegment self, int index, MemorySegment length) {
        var mh$ = ts_query_capture_name_for_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_capture_name_for_id", self, index, length);
            }
            return (MemorySegment)mh$.invokeExact(self, index, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_capture_quantifier_for_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_capture_quantifier_for_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSQuantifier ts_query_capture_quantifier_for_id(const TSQuery *self, uint32_t pattern_index, uint32_t capture_index)
     * }
     */
    public static FunctionDescriptor ts_query_capture_quantifier_for_id$descriptor() {
        return ts_query_capture_quantifier_for_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSQuantifier ts_query_capture_quantifier_for_id(const TSQuery *self, uint32_t pattern_index, uint32_t capture_index)
     * }
     */
    public static MethodHandle ts_query_capture_quantifier_for_id$handle() {
        return ts_query_capture_quantifier_for_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSQuantifier ts_query_capture_quantifier_for_id(const TSQuery *self, uint32_t pattern_index, uint32_t capture_index)
     * }
     */
    public static MemorySegment ts_query_capture_quantifier_for_id$address() {
        return ts_query_capture_quantifier_for_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSQuantifier ts_query_capture_quantifier_for_id(const TSQuery *self, uint32_t pattern_index, uint32_t capture_index)
     * }
     */
    public static int ts_query_capture_quantifier_for_id(MemorySegment self, int pattern_index, int capture_index) {
        var mh$ = ts_query_capture_quantifier_for_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_capture_quantifier_for_id", self, pattern_index, capture_index);
            }
            return (int)mh$.invokeExact(self, pattern_index, capture_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_string_value_for_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_string_value_for_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ts_query_string_value_for_id(const TSQuery *self, uint32_t index, uint32_t *length)
     * }
     */
    public static FunctionDescriptor ts_query_string_value_for_id$descriptor() {
        return ts_query_string_value_for_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ts_query_string_value_for_id(const TSQuery *self, uint32_t index, uint32_t *length)
     * }
     */
    public static MethodHandle ts_query_string_value_for_id$handle() {
        return ts_query_string_value_for_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ts_query_string_value_for_id(const TSQuery *self, uint32_t index, uint32_t *length)
     * }
     */
    public static MemorySegment ts_query_string_value_for_id$address() {
        return ts_query_string_value_for_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ts_query_string_value_for_id(const TSQuery *self, uint32_t index, uint32_t *length)
     * }
     */
    public static MemorySegment ts_query_string_value_for_id(MemorySegment self, int index, MemorySegment length) {
        var mh$ = ts_query_string_value_for_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_string_value_for_id", self, index, length);
            }
            return (MemorySegment)mh$.invokeExact(self, index, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_disable_capture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_disable_capture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_query_disable_capture(TSQuery *self, const char *name, uint32_t length)
     * }
     */
    public static FunctionDescriptor ts_query_disable_capture$descriptor() {
        return ts_query_disable_capture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_query_disable_capture(TSQuery *self, const char *name, uint32_t length)
     * }
     */
    public static MethodHandle ts_query_disable_capture$handle() {
        return ts_query_disable_capture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_query_disable_capture(TSQuery *self, const char *name, uint32_t length)
     * }
     */
    public static MemorySegment ts_query_disable_capture$address() {
        return ts_query_disable_capture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_query_disable_capture(TSQuery *self, const char *name, uint32_t length)
     * }
     */
    public static void ts_query_disable_capture(MemorySegment self, MemorySegment name, int length) {
        var mh$ = ts_query_disable_capture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_disable_capture", self, name, length);
            }
            mh$.invokeExact(self, name, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_disable_pattern {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_disable_pattern");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_query_disable_pattern(TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static FunctionDescriptor ts_query_disable_pattern$descriptor() {
        return ts_query_disable_pattern.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_query_disable_pattern(TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static MethodHandle ts_query_disable_pattern$handle() {
        return ts_query_disable_pattern.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_query_disable_pattern(TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static MemorySegment ts_query_disable_pattern$address() {
        return ts_query_disable_pattern.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_query_disable_pattern(TSQuery *self, uint32_t pattern_index)
     * }
     */
    public static void ts_query_disable_pattern(MemorySegment self, int pattern_index) {
        var mh$ = ts_query_disable_pattern.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_disable_pattern", self, pattern_index);
            }
            mh$.invokeExact(self, pattern_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_cursor_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER    );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_cursor_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSQueryCursor *ts_query_cursor_new()
     * }
     */
    public static FunctionDescriptor ts_query_cursor_new$descriptor() {
        return ts_query_cursor_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSQueryCursor *ts_query_cursor_new()
     * }
     */
    public static MethodHandle ts_query_cursor_new$handle() {
        return ts_query_cursor_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSQueryCursor *ts_query_cursor_new()
     * }
     */
    public static MemorySegment ts_query_cursor_new$address() {
        return ts_query_cursor_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSQueryCursor *ts_query_cursor_new()
     * }
     */
    public static MemorySegment ts_query_cursor_new() {
        var mh$ = ts_query_cursor_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_cursor_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_cursor_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_cursor_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_query_cursor_delete(TSQueryCursor *self)
     * }
     */
    public static FunctionDescriptor ts_query_cursor_delete$descriptor() {
        return ts_query_cursor_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_query_cursor_delete(TSQueryCursor *self)
     * }
     */
    public static MethodHandle ts_query_cursor_delete$handle() {
        return ts_query_cursor_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_query_cursor_delete(TSQueryCursor *self)
     * }
     */
    public static MemorySegment ts_query_cursor_delete$address() {
        return ts_query_cursor_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_query_cursor_delete(TSQueryCursor *self)
     * }
     */
    public static void ts_query_cursor_delete(MemorySegment self) {
        var mh$ = ts_query_cursor_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_cursor_delete", self);
            }
            mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_cursor_exec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TSNode.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_cursor_exec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_query_cursor_exec(TSQueryCursor *self, const TSQuery *query, TSNode node)
     * }
     */
    public static FunctionDescriptor ts_query_cursor_exec$descriptor() {
        return ts_query_cursor_exec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_query_cursor_exec(TSQueryCursor *self, const TSQuery *query, TSNode node)
     * }
     */
    public static MethodHandle ts_query_cursor_exec$handle() {
        return ts_query_cursor_exec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_query_cursor_exec(TSQueryCursor *self, const TSQuery *query, TSNode node)
     * }
     */
    public static MemorySegment ts_query_cursor_exec$address() {
        return ts_query_cursor_exec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_query_cursor_exec(TSQueryCursor *self, const TSQuery *query, TSNode node)
     * }
     */
    public static void ts_query_cursor_exec(MemorySegment self, MemorySegment query, MemorySegment node) {
        var mh$ = ts_query_cursor_exec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_cursor_exec", self, query, node);
            }
            mh$.invokeExact(self, query, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_cursor_did_exceed_match_limit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_cursor_did_exceed_match_limit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_query_cursor_did_exceed_match_limit(const TSQueryCursor *self)
     * }
     */
    public static FunctionDescriptor ts_query_cursor_did_exceed_match_limit$descriptor() {
        return ts_query_cursor_did_exceed_match_limit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_query_cursor_did_exceed_match_limit(const TSQueryCursor *self)
     * }
     */
    public static MethodHandle ts_query_cursor_did_exceed_match_limit$handle() {
        return ts_query_cursor_did_exceed_match_limit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_query_cursor_did_exceed_match_limit(const TSQueryCursor *self)
     * }
     */
    public static MemorySegment ts_query_cursor_did_exceed_match_limit$address() {
        return ts_query_cursor_did_exceed_match_limit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_query_cursor_did_exceed_match_limit(const TSQueryCursor *self)
     * }
     */
    public static boolean ts_query_cursor_did_exceed_match_limit(MemorySegment self) {
        var mh$ = ts_query_cursor_did_exceed_match_limit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_cursor_did_exceed_match_limit", self);
            }
            return (boolean)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_cursor_match_limit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_cursor_match_limit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_query_cursor_match_limit(const TSQueryCursor *self)
     * }
     */
    public static FunctionDescriptor ts_query_cursor_match_limit$descriptor() {
        return ts_query_cursor_match_limit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_query_cursor_match_limit(const TSQueryCursor *self)
     * }
     */
    public static MethodHandle ts_query_cursor_match_limit$handle() {
        return ts_query_cursor_match_limit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_query_cursor_match_limit(const TSQueryCursor *self)
     * }
     */
    public static MemorySegment ts_query_cursor_match_limit$address() {
        return ts_query_cursor_match_limit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_query_cursor_match_limit(const TSQueryCursor *self)
     * }
     */
    public static int ts_query_cursor_match_limit(MemorySegment self) {
        var mh$ = ts_query_cursor_match_limit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_cursor_match_limit", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_cursor_set_match_limit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_cursor_set_match_limit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_query_cursor_set_match_limit(TSQueryCursor *self, uint32_t limit)
     * }
     */
    public static FunctionDescriptor ts_query_cursor_set_match_limit$descriptor() {
        return ts_query_cursor_set_match_limit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_query_cursor_set_match_limit(TSQueryCursor *self, uint32_t limit)
     * }
     */
    public static MethodHandle ts_query_cursor_set_match_limit$handle() {
        return ts_query_cursor_set_match_limit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_query_cursor_set_match_limit(TSQueryCursor *self, uint32_t limit)
     * }
     */
    public static MemorySegment ts_query_cursor_set_match_limit$address() {
        return ts_query_cursor_set_match_limit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_query_cursor_set_match_limit(TSQueryCursor *self, uint32_t limit)
     * }
     */
    public static void ts_query_cursor_set_match_limit(MemorySegment self, int limit) {
        var mh$ = ts_query_cursor_set_match_limit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_cursor_set_match_limit", self, limit);
            }
            mh$.invokeExact(self, limit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_cursor_set_byte_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_INT,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_cursor_set_byte_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_query_cursor_set_byte_range(TSQueryCursor *self, uint32_t start_byte, uint32_t end_byte)
     * }
     */
    public static FunctionDescriptor ts_query_cursor_set_byte_range$descriptor() {
        return ts_query_cursor_set_byte_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_query_cursor_set_byte_range(TSQueryCursor *self, uint32_t start_byte, uint32_t end_byte)
     * }
     */
    public static MethodHandle ts_query_cursor_set_byte_range$handle() {
        return ts_query_cursor_set_byte_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_query_cursor_set_byte_range(TSQueryCursor *self, uint32_t start_byte, uint32_t end_byte)
     * }
     */
    public static MemorySegment ts_query_cursor_set_byte_range$address() {
        return ts_query_cursor_set_byte_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_query_cursor_set_byte_range(TSQueryCursor *self, uint32_t start_byte, uint32_t end_byte)
     * }
     */
    public static void ts_query_cursor_set_byte_range(MemorySegment self, int start_byte, int end_byte) {
        var mh$ = ts_query_cursor_set_byte_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_cursor_set_byte_range", self, start_byte, end_byte);
            }
            mh$.invokeExact(self, start_byte, end_byte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_cursor_set_point_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TSPoint.layout(),
            TSPoint.layout()
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_cursor_set_point_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_query_cursor_set_point_range(TSQueryCursor *self, TSPoint start_point, TSPoint end_point)
     * }
     */
    public static FunctionDescriptor ts_query_cursor_set_point_range$descriptor() {
        return ts_query_cursor_set_point_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_query_cursor_set_point_range(TSQueryCursor *self, TSPoint start_point, TSPoint end_point)
     * }
     */
    public static MethodHandle ts_query_cursor_set_point_range$handle() {
        return ts_query_cursor_set_point_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_query_cursor_set_point_range(TSQueryCursor *self, TSPoint start_point, TSPoint end_point)
     * }
     */
    public static MemorySegment ts_query_cursor_set_point_range$address() {
        return ts_query_cursor_set_point_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_query_cursor_set_point_range(TSQueryCursor *self, TSPoint start_point, TSPoint end_point)
     * }
     */
    public static void ts_query_cursor_set_point_range(MemorySegment self, MemorySegment start_point, MemorySegment end_point) {
        var mh$ = ts_query_cursor_set_point_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_cursor_set_point_range", self, start_point, end_point);
            }
            mh$.invokeExact(self, start_point, end_point);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_cursor_next_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_cursor_next_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_query_cursor_next_match(TSQueryCursor *self, TSQueryMatch *match)
     * }
     */
    public static FunctionDescriptor ts_query_cursor_next_match$descriptor() {
        return ts_query_cursor_next_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_query_cursor_next_match(TSQueryCursor *self, TSQueryMatch *match)
     * }
     */
    public static MethodHandle ts_query_cursor_next_match$handle() {
        return ts_query_cursor_next_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_query_cursor_next_match(TSQueryCursor *self, TSQueryMatch *match)
     * }
     */
    public static MemorySegment ts_query_cursor_next_match$address() {
        return ts_query_cursor_next_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_query_cursor_next_match(TSQueryCursor *self, TSQueryMatch *match)
     * }
     */
    public static boolean ts_query_cursor_next_match(MemorySegment self, MemorySegment match) {
        var mh$ = ts_query_cursor_next_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_cursor_next_match", self, match);
            }
            return (boolean)mh$.invokeExact(self, match);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_cursor_remove_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_cursor_remove_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_query_cursor_remove_match(TSQueryCursor *self, uint32_t match_id)
     * }
     */
    public static FunctionDescriptor ts_query_cursor_remove_match$descriptor() {
        return ts_query_cursor_remove_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_query_cursor_remove_match(TSQueryCursor *self, uint32_t match_id)
     * }
     */
    public static MethodHandle ts_query_cursor_remove_match$handle() {
        return ts_query_cursor_remove_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_query_cursor_remove_match(TSQueryCursor *self, uint32_t match_id)
     * }
     */
    public static MemorySegment ts_query_cursor_remove_match$address() {
        return ts_query_cursor_remove_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_query_cursor_remove_match(TSQueryCursor *self, uint32_t match_id)
     * }
     */
    public static void ts_query_cursor_remove_match(MemorySegment self, int match_id) {
        var mh$ = ts_query_cursor_remove_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_cursor_remove_match", self, match_id);
            }
            mh$.invokeExact(self, match_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_cursor_next_capture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_cursor_next_capture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_query_cursor_next_capture(TSQueryCursor *self, TSQueryMatch *match, uint32_t *capture_index)
     * }
     */
    public static FunctionDescriptor ts_query_cursor_next_capture$descriptor() {
        return ts_query_cursor_next_capture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_query_cursor_next_capture(TSQueryCursor *self, TSQueryMatch *match, uint32_t *capture_index)
     * }
     */
    public static MethodHandle ts_query_cursor_next_capture$handle() {
        return ts_query_cursor_next_capture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_query_cursor_next_capture(TSQueryCursor *self, TSQueryMatch *match, uint32_t *capture_index)
     * }
     */
    public static MemorySegment ts_query_cursor_next_capture$address() {
        return ts_query_cursor_next_capture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_query_cursor_next_capture(TSQueryCursor *self, TSQueryMatch *match, uint32_t *capture_index)
     * }
     */
    public static boolean ts_query_cursor_next_capture(MemorySegment self, MemorySegment match, MemorySegment capture_index) {
        var mh$ = ts_query_cursor_next_capture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_cursor_next_capture", self, match, capture_index);
            }
            return (boolean)mh$.invokeExact(self, match, capture_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_query_cursor_set_max_start_depth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_query_cursor_set_max_start_depth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_query_cursor_set_max_start_depth(TSQueryCursor *self, uint32_t max_start_depth)
     * }
     */
    public static FunctionDescriptor ts_query_cursor_set_max_start_depth$descriptor() {
        return ts_query_cursor_set_max_start_depth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_query_cursor_set_max_start_depth(TSQueryCursor *self, uint32_t max_start_depth)
     * }
     */
    public static MethodHandle ts_query_cursor_set_max_start_depth$handle() {
        return ts_query_cursor_set_max_start_depth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_query_cursor_set_max_start_depth(TSQueryCursor *self, uint32_t max_start_depth)
     * }
     */
    public static MemorySegment ts_query_cursor_set_max_start_depth$address() {
        return ts_query_cursor_set_max_start_depth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_query_cursor_set_max_start_depth(TSQueryCursor *self, uint32_t max_start_depth)
     * }
     */
    public static void ts_query_cursor_set_max_start_depth(MemorySegment self, int max_start_depth) {
        var mh$ = ts_query_cursor_set_max_start_depth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_query_cursor_set_max_start_depth", self, max_start_depth);
            }
            mh$.invokeExact(self, max_start_depth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_language_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_language_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const TSLanguage *ts_language_copy(const TSLanguage *self)
     * }
     */
    public static FunctionDescriptor ts_language_copy$descriptor() {
        return ts_language_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const TSLanguage *ts_language_copy(const TSLanguage *self)
     * }
     */
    public static MethodHandle ts_language_copy$handle() {
        return ts_language_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const TSLanguage *ts_language_copy(const TSLanguage *self)
     * }
     */
    public static MemorySegment ts_language_copy$address() {
        return ts_language_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const TSLanguage *ts_language_copy(const TSLanguage *self)
     * }
     */
    public static MemorySegment ts_language_copy(MemorySegment self) {
        var mh$ = ts_language_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_language_copy", self);
            }
            return (MemorySegment)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_language_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_language_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_language_delete(const TSLanguage *self)
     * }
     */
    public static FunctionDescriptor ts_language_delete$descriptor() {
        return ts_language_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_language_delete(const TSLanguage *self)
     * }
     */
    public static MethodHandle ts_language_delete$handle() {
        return ts_language_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_language_delete(const TSLanguage *self)
     * }
     */
    public static MemorySegment ts_language_delete$address() {
        return ts_language_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_language_delete(const TSLanguage *self)
     * }
     */
    public static void ts_language_delete(MemorySegment self) {
        var mh$ = ts_language_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_language_delete", self);
            }
            mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_language_symbol_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_language_symbol_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_language_symbol_count(const TSLanguage *self)
     * }
     */
    public static FunctionDescriptor ts_language_symbol_count$descriptor() {
        return ts_language_symbol_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_language_symbol_count(const TSLanguage *self)
     * }
     */
    public static MethodHandle ts_language_symbol_count$handle() {
        return ts_language_symbol_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_language_symbol_count(const TSLanguage *self)
     * }
     */
    public static MemorySegment ts_language_symbol_count$address() {
        return ts_language_symbol_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_language_symbol_count(const TSLanguage *self)
     * }
     */
    public static int ts_language_symbol_count(MemorySegment self) {
        var mh$ = ts_language_symbol_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_language_symbol_count", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_language_state_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_language_state_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_language_state_count(const TSLanguage *self)
     * }
     */
    public static FunctionDescriptor ts_language_state_count$descriptor() {
        return ts_language_state_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_language_state_count(const TSLanguage *self)
     * }
     */
    public static MethodHandle ts_language_state_count$handle() {
        return ts_language_state_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_language_state_count(const TSLanguage *self)
     * }
     */
    public static MemorySegment ts_language_state_count$address() {
        return ts_language_state_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_language_state_count(const TSLanguage *self)
     * }
     */
    public static int ts_language_state_count(MemorySegment self) {
        var mh$ = ts_language_state_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_language_state_count", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_language_symbol_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_SHORT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_language_symbol_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ts_language_symbol_name(const TSLanguage *self, TSSymbol symbol)
     * }
     */
    public static FunctionDescriptor ts_language_symbol_name$descriptor() {
        return ts_language_symbol_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ts_language_symbol_name(const TSLanguage *self, TSSymbol symbol)
     * }
     */
    public static MethodHandle ts_language_symbol_name$handle() {
        return ts_language_symbol_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ts_language_symbol_name(const TSLanguage *self, TSSymbol symbol)
     * }
     */
    public static MemorySegment ts_language_symbol_name$address() {
        return ts_language_symbol_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ts_language_symbol_name(const TSLanguage *self, TSSymbol symbol)
     * }
     */
    public static MemorySegment ts_language_symbol_name(MemorySegment self, short symbol) {
        var mh$ = ts_language_symbol_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_language_symbol_name", self, symbol);
            }
            return (MemorySegment)mh$.invokeExact(self, symbol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_language_symbol_for_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_SHORT,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT,
            TreeSitter.C_BOOL
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_language_symbol_for_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSSymbol ts_language_symbol_for_name(const TSLanguage *self, const char *string, uint32_t length, _Bool is_named)
     * }
     */
    public static FunctionDescriptor ts_language_symbol_for_name$descriptor() {
        return ts_language_symbol_for_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSSymbol ts_language_symbol_for_name(const TSLanguage *self, const char *string, uint32_t length, _Bool is_named)
     * }
     */
    public static MethodHandle ts_language_symbol_for_name$handle() {
        return ts_language_symbol_for_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSSymbol ts_language_symbol_for_name(const TSLanguage *self, const char *string, uint32_t length, _Bool is_named)
     * }
     */
    public static MemorySegment ts_language_symbol_for_name$address() {
        return ts_language_symbol_for_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSSymbol ts_language_symbol_for_name(const TSLanguage *self, const char *string, uint32_t length, _Bool is_named)
     * }
     */
    public static short ts_language_symbol_for_name(MemorySegment self, MemorySegment string, int length, boolean is_named) {
        var mh$ = ts_language_symbol_for_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_language_symbol_for_name", self, string, length, is_named);
            }
            return (short)mh$.invokeExact(self, string, length, is_named);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_language_field_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_language_field_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_language_field_count(const TSLanguage *self)
     * }
     */
    public static FunctionDescriptor ts_language_field_count$descriptor() {
        return ts_language_field_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_language_field_count(const TSLanguage *self)
     * }
     */
    public static MethodHandle ts_language_field_count$handle() {
        return ts_language_field_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_language_field_count(const TSLanguage *self)
     * }
     */
    public static MemorySegment ts_language_field_count$address() {
        return ts_language_field_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_language_field_count(const TSLanguage *self)
     * }
     */
    public static int ts_language_field_count(MemorySegment self) {
        var mh$ = ts_language_field_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_language_field_count", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_language_field_name_for_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_SHORT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_language_field_name_for_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ts_language_field_name_for_id(const TSLanguage *self, TSFieldId id)
     * }
     */
    public static FunctionDescriptor ts_language_field_name_for_id$descriptor() {
        return ts_language_field_name_for_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ts_language_field_name_for_id(const TSLanguage *self, TSFieldId id)
     * }
     */
    public static MethodHandle ts_language_field_name_for_id$handle() {
        return ts_language_field_name_for_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ts_language_field_name_for_id(const TSLanguage *self, TSFieldId id)
     * }
     */
    public static MemorySegment ts_language_field_name_for_id$address() {
        return ts_language_field_name_for_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ts_language_field_name_for_id(const TSLanguage *self, TSFieldId id)
     * }
     */
    public static MemorySegment ts_language_field_name_for_id(MemorySegment self, short id) {
        var mh$ = ts_language_field_name_for_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_language_field_name_for_id", self, id);
            }
            return (MemorySegment)mh$.invokeExact(self, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_language_field_id_for_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_SHORT,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_INT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_language_field_id_for_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSFieldId ts_language_field_id_for_name(const TSLanguage *self, const char *name, uint32_t name_length)
     * }
     */
    public static FunctionDescriptor ts_language_field_id_for_name$descriptor() {
        return ts_language_field_id_for_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSFieldId ts_language_field_id_for_name(const TSLanguage *self, const char *name, uint32_t name_length)
     * }
     */
    public static MethodHandle ts_language_field_id_for_name$handle() {
        return ts_language_field_id_for_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSFieldId ts_language_field_id_for_name(const TSLanguage *self, const char *name, uint32_t name_length)
     * }
     */
    public static MemorySegment ts_language_field_id_for_name$address() {
        return ts_language_field_id_for_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSFieldId ts_language_field_id_for_name(const TSLanguage *self, const char *name, uint32_t name_length)
     * }
     */
    public static short ts_language_field_id_for_name(MemorySegment self, MemorySegment name, int name_length) {
        var mh$ = ts_language_field_id_for_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_language_field_id_for_name", self, name, name_length);
            }
            return (short)mh$.invokeExact(self, name, name_length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_language_symbol_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TreeSitter.C_POINTER,
            TreeSitter.C_SHORT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_language_symbol_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSSymbolType ts_language_symbol_type(const TSLanguage *self, TSSymbol symbol)
     * }
     */
    public static FunctionDescriptor ts_language_symbol_type$descriptor() {
        return ts_language_symbol_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSSymbolType ts_language_symbol_type(const TSLanguage *self, TSSymbol symbol)
     * }
     */
    public static MethodHandle ts_language_symbol_type$handle() {
        return ts_language_symbol_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSSymbolType ts_language_symbol_type(const TSLanguage *self, TSSymbol symbol)
     * }
     */
    public static MemorySegment ts_language_symbol_type$address() {
        return ts_language_symbol_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSSymbolType ts_language_symbol_type(const TSLanguage *self, TSSymbol symbol)
     * }
     */
    public static int ts_language_symbol_type(MemorySegment self, short symbol) {
        var mh$ = ts_language_symbol_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_language_symbol_type", self, symbol);
            }
            return (int)mh$.invokeExact(self, symbol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_language_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_INT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_language_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t ts_language_version(const TSLanguage *self)
     * }
     */
    public static FunctionDescriptor ts_language_version$descriptor() {
        return ts_language_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t ts_language_version(const TSLanguage *self)
     * }
     */
    public static MethodHandle ts_language_version$handle() {
        return ts_language_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t ts_language_version(const TSLanguage *self)
     * }
     */
    public static MemorySegment ts_language_version$address() {
        return ts_language_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t ts_language_version(const TSLanguage *self)
     * }
     */
    public static int ts_language_version(MemorySegment self) {
        var mh$ = ts_language_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_language_version", self);
            }
            return (int)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_language_next_state {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_SHORT,
            TreeSitter.C_POINTER,
            TreeSitter.C_SHORT,
            TreeSitter.C_SHORT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_language_next_state");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSStateId ts_language_next_state(const TSLanguage *self, TSStateId state, TSSymbol symbol)
     * }
     */
    public static FunctionDescriptor ts_language_next_state$descriptor() {
        return ts_language_next_state.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSStateId ts_language_next_state(const TSLanguage *self, TSStateId state, TSSymbol symbol)
     * }
     */
    public static MethodHandle ts_language_next_state$handle() {
        return ts_language_next_state.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSStateId ts_language_next_state(const TSLanguage *self, TSStateId state, TSSymbol symbol)
     * }
     */
    public static MemorySegment ts_language_next_state$address() {
        return ts_language_next_state.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSStateId ts_language_next_state(const TSLanguage *self, TSStateId state, TSSymbol symbol)
     * }
     */
    public static short ts_language_next_state(MemorySegment self, short state, short symbol) {
        var mh$ = ts_language_next_state.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_language_next_state", self, state, symbol);
            }
            return (short)mh$.invokeExact(self, state, symbol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_lookahead_iterator_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_SHORT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_lookahead_iterator_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSLookaheadIterator *ts_lookahead_iterator_new(const TSLanguage *self, TSStateId state)
     * }
     */
    public static FunctionDescriptor ts_lookahead_iterator_new$descriptor() {
        return ts_lookahead_iterator_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSLookaheadIterator *ts_lookahead_iterator_new(const TSLanguage *self, TSStateId state)
     * }
     */
    public static MethodHandle ts_lookahead_iterator_new$handle() {
        return ts_lookahead_iterator_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSLookaheadIterator *ts_lookahead_iterator_new(const TSLanguage *self, TSStateId state)
     * }
     */
    public static MemorySegment ts_lookahead_iterator_new$address() {
        return ts_lookahead_iterator_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSLookaheadIterator *ts_lookahead_iterator_new(const TSLanguage *self, TSStateId state)
     * }
     */
    public static MemorySegment ts_lookahead_iterator_new(MemorySegment self, short state) {
        var mh$ = ts_lookahead_iterator_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_lookahead_iterator_new", self, state);
            }
            return (MemorySegment)mh$.invokeExact(self, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_lookahead_iterator_delete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_lookahead_iterator_delete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ts_lookahead_iterator_delete(TSLookaheadIterator *self)
     * }
     */
    public static FunctionDescriptor ts_lookahead_iterator_delete$descriptor() {
        return ts_lookahead_iterator_delete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ts_lookahead_iterator_delete(TSLookaheadIterator *self)
     * }
     */
    public static MethodHandle ts_lookahead_iterator_delete$handle() {
        return ts_lookahead_iterator_delete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ts_lookahead_iterator_delete(TSLookaheadIterator *self)
     * }
     */
    public static MemorySegment ts_lookahead_iterator_delete$address() {
        return ts_lookahead_iterator_delete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ts_lookahead_iterator_delete(TSLookaheadIterator *self)
     * }
     */
    public static void ts_lookahead_iterator_delete(MemorySegment self) {
        var mh$ = ts_lookahead_iterator_delete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_lookahead_iterator_delete", self);
            }
            mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_lookahead_iterator_reset_state {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER,
            TreeSitter.C_SHORT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_lookahead_iterator_reset_state");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_lookahead_iterator_reset_state(TSLookaheadIterator *self, TSStateId state)
     * }
     */
    public static FunctionDescriptor ts_lookahead_iterator_reset_state$descriptor() {
        return ts_lookahead_iterator_reset_state.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_lookahead_iterator_reset_state(TSLookaheadIterator *self, TSStateId state)
     * }
     */
    public static MethodHandle ts_lookahead_iterator_reset_state$handle() {
        return ts_lookahead_iterator_reset_state.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_lookahead_iterator_reset_state(TSLookaheadIterator *self, TSStateId state)
     * }
     */
    public static MemorySegment ts_lookahead_iterator_reset_state$address() {
        return ts_lookahead_iterator_reset_state.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_lookahead_iterator_reset_state(TSLookaheadIterator *self, TSStateId state)
     * }
     */
    public static boolean ts_lookahead_iterator_reset_state(MemorySegment self, short state) {
        var mh$ = ts_lookahead_iterator_reset_state.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_lookahead_iterator_reset_state", self, state);
            }
            return (boolean)mh$.invokeExact(self, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_lookahead_iterator_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER,
            TreeSitter.C_SHORT
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_lookahead_iterator_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_lookahead_iterator_reset(TSLookaheadIterator *self, const TSLanguage *language, TSStateId state)
     * }
     */
    public static FunctionDescriptor ts_lookahead_iterator_reset$descriptor() {
        return ts_lookahead_iterator_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_lookahead_iterator_reset(TSLookaheadIterator *self, const TSLanguage *language, TSStateId state)
     * }
     */
    public static MethodHandle ts_lookahead_iterator_reset$handle() {
        return ts_lookahead_iterator_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_lookahead_iterator_reset(TSLookaheadIterator *self, const TSLanguage *language, TSStateId state)
     * }
     */
    public static MemorySegment ts_lookahead_iterator_reset$address() {
        return ts_lookahead_iterator_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_lookahead_iterator_reset(TSLookaheadIterator *self, const TSLanguage *language, TSStateId state)
     * }
     */
    public static boolean ts_lookahead_iterator_reset(MemorySegment self, MemorySegment language, short state) {
        var mh$ = ts_lookahead_iterator_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_lookahead_iterator_reset", self, language, state);
            }
            return (boolean)mh$.invokeExact(self, language, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_lookahead_iterator_language {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_lookahead_iterator_language");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const TSLanguage *ts_lookahead_iterator_language(const TSLookaheadIterator *self)
     * }
     */
    public static FunctionDescriptor ts_lookahead_iterator_language$descriptor() {
        return ts_lookahead_iterator_language.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const TSLanguage *ts_lookahead_iterator_language(const TSLookaheadIterator *self)
     * }
     */
    public static MethodHandle ts_lookahead_iterator_language$handle() {
        return ts_lookahead_iterator_language.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const TSLanguage *ts_lookahead_iterator_language(const TSLookaheadIterator *self)
     * }
     */
    public static MemorySegment ts_lookahead_iterator_language$address() {
        return ts_lookahead_iterator_language.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const TSLanguage *ts_lookahead_iterator_language(const TSLookaheadIterator *self)
     * }
     */
    public static MemorySegment ts_lookahead_iterator_language(MemorySegment self) {
        var mh$ = ts_lookahead_iterator_language.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_lookahead_iterator_language", self);
            }
            return (MemorySegment)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_lookahead_iterator_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_BOOL,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_lookahead_iterator_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool ts_lookahead_iterator_next(TSLookaheadIterator *self)
     * }
     */
    public static FunctionDescriptor ts_lookahead_iterator_next$descriptor() {
        return ts_lookahead_iterator_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool ts_lookahead_iterator_next(TSLookaheadIterator *self)
     * }
     */
    public static MethodHandle ts_lookahead_iterator_next$handle() {
        return ts_lookahead_iterator_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool ts_lookahead_iterator_next(TSLookaheadIterator *self)
     * }
     */
    public static MemorySegment ts_lookahead_iterator_next$address() {
        return ts_lookahead_iterator_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool ts_lookahead_iterator_next(TSLookaheadIterator *self)
     * }
     */
    public static boolean ts_lookahead_iterator_next(MemorySegment self) {
        var mh$ = ts_lookahead_iterator_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_lookahead_iterator_next", self);
            }
            return (boolean)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_lookahead_iterator_current_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_SHORT,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_lookahead_iterator_current_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * TSSymbol ts_lookahead_iterator_current_symbol(const TSLookaheadIterator *self)
     * }
     */
    public static FunctionDescriptor ts_lookahead_iterator_current_symbol$descriptor() {
        return ts_lookahead_iterator_current_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * TSSymbol ts_lookahead_iterator_current_symbol(const TSLookaheadIterator *self)
     * }
     */
    public static MethodHandle ts_lookahead_iterator_current_symbol$handle() {
        return ts_lookahead_iterator_current_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * TSSymbol ts_lookahead_iterator_current_symbol(const TSLookaheadIterator *self)
     * }
     */
    public static MemorySegment ts_lookahead_iterator_current_symbol$address() {
        return ts_lookahead_iterator_current_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * TSSymbol ts_lookahead_iterator_current_symbol(const TSLookaheadIterator *self)
     * }
     */
    public static short ts_lookahead_iterator_current_symbol(MemorySegment self) {
        var mh$ = ts_lookahead_iterator_current_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_lookahead_iterator_current_symbol", self);
            }
            return (short)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ts_lookahead_iterator_current_symbol_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TreeSitter.C_POINTER,
            TreeSitter.C_POINTER
        );

        public static final MemorySegment ADDR = TreeSitter.findOrThrow("ts_lookahead_iterator_current_symbol_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *ts_lookahead_iterator_current_symbol_name(const TSLookaheadIterator *self)
     * }
     */
    public static FunctionDescriptor ts_lookahead_iterator_current_symbol_name$descriptor() {
        return ts_lookahead_iterator_current_symbol_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *ts_lookahead_iterator_current_symbol_name(const TSLookaheadIterator *self)
     * }
     */
    public static MethodHandle ts_lookahead_iterator_current_symbol_name$handle() {
        return ts_lookahead_iterator_current_symbol_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *ts_lookahead_iterator_current_symbol_name(const TSLookaheadIterator *self)
     * }
     */
    public static MemorySegment ts_lookahead_iterator_current_symbol_name$address() {
        return ts_lookahead_iterator_current_symbol_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *ts_lookahead_iterator_current_symbol_name(const TSLookaheadIterator *self)
     * }
     */
    public static MemorySegment ts_lookahead_iterator_current_symbol_name(MemorySegment self) {
        var mh$ = ts_lookahead_iterator_current_symbol_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ts_lookahead_iterator_current_symbol_name", self);
            }
            return (MemorySegment)mh$.invokeExact(self);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

